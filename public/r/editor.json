{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "editor",
  "type": "registry:block",
  "title": "Rich Text Editor",
  "description": "A powerful Lexical-based rich text editor with markdown support, slash commands, floating toolbar, speech-to-text, and table editing capabilities. Built with Tailwind v4 and OKLCH colors.",
  "dependencies": [
    "@lexical/react@^0.38.2",
    "@lexical/utils@^0.38.2",
    "lexical@^0.38.2",
    "@lexical/code@^0.38.2",
    "@lexical/html@^0.38.2",
    "@lexical/link@^0.38.2",
    "@lexical/list@^0.38.2",
    "@lexical/markdown@^0.38.2",
    "@lexical/rich-text@^0.38.2",
    "@lexical/selection@^0.38.2",
    "@lexical/table@^0.38.2"
  ],
  "registryDependencies": [
    "https://uruhuu.vercel.app/r/button.json",
    "https://uruhuu.vercel.app/r/tooltip.json",
    "https://uruhuu.vercel.app/r/popover.json",
    "https://uruhuu.vercel.app/r/menu.json",
    "https://uruhuu.vercel.app/r/dialog.json",
    "https://uruhuu.vercel.app/r/input.json",
    "https://uruhuu.vercel.app/r/label.json",
    "https://uruhuu.vercel.app/r/separator.json"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/editor/index.tsx",
      "content": "\"use client\";\nimport { TRANSFORMERS } from \"@lexical/markdown\";\nimport { AutoFocusPlugin } from \"@lexical/react/LexicalAutoFocusPlugin\";\nimport { CheckListPlugin } from \"@lexical/react/LexicalCheckListPlugin\";\nimport { LexicalComposer } from \"@lexical/react/LexicalComposer\";\nimport { ContentEditable } from \"@lexical/react/LexicalContentEditable\";\nimport { LexicalErrorBoundary } from \"@lexical/react/LexicalErrorBoundary\";\nimport { HistoryPlugin } from \"@lexical/react/LexicalHistoryPlugin\";\nimport { HorizontalRulePlugin } from \"@lexical/react/LexicalHorizontalRulePlugin\";\nimport { LinkPlugin } from \"@lexical/react/LexicalLinkPlugin\";\nimport { ListPlugin } from \"@lexical/react/LexicalListPlugin\";\nimport { MarkdownShortcutPlugin } from \"@lexical/react/LexicalMarkdownShortcutPlugin\";\nimport { OnChangePlugin } from \"@lexical/react/LexicalOnChangePlugin\";\nimport { RichTextPlugin } from \"@lexical/react/LexicalRichTextPlugin\";\nimport { TablePlugin } from \"@lexical/react/LexicalTablePlugin\";\nimport type { EditorState, LexicalEditor } from \"lexical\";\nimport type React from \"react\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { cn } from \"@/registry/new-york/libs/utils\";\nimport { EDITOR_CONFIG } from \"./lib/configs\";\nimport type { EditorProps } from \"./lib/types/editor\";\nimport { FloatingToolbar } from \"./plugins/floating-toolbar\";\nimport SlashCommandPlugin from \"./plugins/slash-command\";\nimport TableHoverActionsPlugin from \"./plugins/table-hover-actions\";\nimport SpeechToTextPlugin from \"./plugins/speech-to-text\";\nimport { Toolbar } from \"./plugins/toolbar\";\nimport { debounce } from \"./lib/debounce\";\n\nfunction EditorContent({\n  placeholder = \"Start writing ...\",\n  className = \"\",\n  minHeight = \"400px\",\n  maxHeight,\n  readOnly = false,\n}: Pick<\n  EditorProps,\n  \"placeholder\" | \"className\" | \"minHeight\" | \"maxHeight\" | \"readOnly\"\n>) {\n  const editorStyle = useMemo(\n    () => ({\n      minHeight,\n      maxHeight,\n      caretColor: \"hsl(var(--editor-primary))\",\n      lineHeight: \"1.7\",\n    }),\n    [minHeight, maxHeight]\n  );\n\n  return (\n    <div className=\"relative w-full\">\n      <RichTextPlugin\n        contentEditable={\n          <ContentEditable\n            className={cn(\n              \"p-6 md:p-8\",\n              \"outline-none\",\n              \"max-w-none\",\n              \"w-full\",\n              \"min-h-[inherit]\",\n              \"will-change-auto\",\n              className\n            )}\n            readOnly={readOnly}\n            style={editorStyle}\n            aria-label=\"Rich text editor\"\n            aria-multiline=\"true\"\n            role=\"textbox\"\n          />\n        }\n        ErrorBoundary={LexicalErrorBoundary}\n        placeholder={\n          <div className=\"absolute top-6 md:top-8 left-6 md:left-8 text-muted-foreground/60 pointer-events-none select-none text-base md:text-lg\">\n            {placeholder}\n          </div>\n        }\n      />\n    </div>\n  );\n}\n\nfunction EditorPlugins({\n  showFloatingToolbar = true,\n  enableSpeechToText = false,\n  customPlugins = [],\n  onChange = () => {},\n}: {\n  showFloatingToolbar?: boolean;\n  enableSpeechToText?: boolean;\n  customPlugins?: React.ComponentType[];\n  onChange: (\n    editorState: EditorState,\n    editor: LexicalEditor,\n    tags: Set<string>\n  ) => void;\n}) {\n  const pluginElements = useMemo(\n    () => customPlugins.map((Plugin, index) => <Plugin key={index} />),\n    [customPlugins]\n  );\n\n  return (\n    <>\n      <HistoryPlugin />\n      <AutoFocusPlugin />\n      <ListPlugin />\n      <CheckListPlugin />\n      <LinkPlugin />\n      <HorizontalRulePlugin />\n      {/* table plugins - order matters */}\n      <TablePlugin\n        hasCellBackgroundColor={true}\n        hasCellMerge={true}\n        hasTabHandler={true}\n      />\n      <TableHoverActionsPlugin />\n      <SlashCommandPlugin />\n      {enableSpeechToText && <SpeechToTextPlugin />}\n      <MarkdownShortcutPlugin transformers={TRANSFORMERS} />\n      <OnChangePlugin onChange={onChange} />\n      {showFloatingToolbar && <FloatingToolbar />}\n      {pluginElements}\n    </>\n  );\n}\n\nexport function Editor({\n  initialValue = \"\",\n  placeholder = 'Start writing or use \"/\" for quick commands',\n  className = \"\",\n  minHeight = \"400px\",\n  maxHeight,\n  showToolbar = false,\n  showFloatingToolbar = true,\n  enableSpeechToText = false,\n  readOnly = false,\n  onChange,\n  plugins = [],\n}: EditorProps) {\n  const onChangeRef = useRef(onChange);\n  onChangeRef.current = onChange;\n\n  const initialConfig = useMemo(\n    () => ({\n      ...EDITOR_CONFIG,\n      editorState: initialValue?.trim() || null,\n      editable: !readOnly,\n    }),\n    [initialValue, readOnly]\n  );\n\n  const handleEditorChange = useCallback(\n    debounce((editorState: EditorState) => {\n      const jsonState = editorState.toJSON();\n      const jsonString = JSON.stringify(jsonState);\n      onChangeRef.current?.(jsonString);\n    }, 300),\n    []\n  );\n\n  return (\n    <div className={cn(\"w-full\", className)}>\n      <LexicalComposer initialConfig={initialConfig}>\n        <div className=\"relative overflow-hidden w-full\">\n          {showToolbar && <Toolbar enableSpeechToText={enableSpeechToText} />}\n\n          <EditorContent\n            maxHeight={maxHeight}\n            minHeight={minHeight}\n            placeholder={placeholder}\n            readOnly={readOnly}\n            className={className}\n          />\n\n          <EditorPlugins\n            customPlugins={plugins}\n            onChange={handleEditorChange}\n            showFloatingToolbar={showFloatingToolbar}\n            enableSpeechToText={enableSpeechToText}\n          />\n        </div>\n      </LexicalComposer>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/index.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/components/image-dialog.tsx",
      "content": "import { Upload } from \"lucide-react\";\nimport type React from \"react\";\nimport { useRef, useState } from \"react\";\n\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/registry/new-york/ui/dialog\";\nimport { Input } from \"@/registry/new-york/ui/input\";\nimport { Label } from \"@/registry/new-york/ui/label\";\n\nexport function ImageDialog({\n  isOpen,\n  onClose,\n  onSubmit,\n}: {\n  isOpen: boolean;\n  onClose: () => void;\n  onSubmit: (src: string, alt: string) => void;\n}) {\n  const [url, setUrl] = useState(\"\");\n  const [alt, setAlt] = useState(\"\");\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (url.trim()) {\n      onSubmit(url.trim(), alt.trim() || \"Image\");\n    }\n    onClose();\n    setUrl(\"\");\n    setAlt(\"\");\n  };\n\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file) {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        const result = e.target?.result as string;\n        if (result) {\n          onSubmit(result, file.name);\n          onClose();\n          setUrl(\"\");\n          setAlt(\"\");\n        }\n      };\n      reader.readAsDataURL(file);\n    }\n  };\n\n  return (\n    <>\n      {isOpen && (\n        <Dialog onOpenChange={onClose} open={isOpen}>\n          <DialogContent\n            aria-describedby=\"image-dialog\"\n            className=\"sm:max-w-md backdrop-blur-md bg-background/95\"\n          >\n            <div>\n              <DialogHeader>\n                <DialogTitle className=\"text-xl font-semibold\">\n                  Insert Image\n                </DialogTitle>\n              </DialogHeader>\n              <div className=\"space-y-4 mt-4\">\n                <form className=\"space-y-4\" onSubmit={handleSubmit}>\n                  <div>\n                    <Label className=\"text-sm font-medium\" htmlFor=\"image-url\">\n                      Image URL\n                    </Label>\n                    <Input\n                      className=\"mt-1.5\"\n                      id=\"image-url\"\n                      onChange={(e) => setUrl(e.target.value)}\n                      placeholder=\"https://example.com/image.jpg\"\n                      value={url}\n                    />\n                  </div>\n                  <div>\n                    <Label className=\"text-sm font-medium\" htmlFor=\"image-alt\">\n                      Alt Text (optional)\n                    </Label>\n                    <Input\n                      className=\"mt-1.5\"\n                      id=\"image-alt\"\n                      onChange={(e) => setAlt(e.target.value)}\n                      placeholder=\"Describe the image\"\n                      value={alt}\n                    />\n                  </div>\n                  <div className=\"flex gap-2 justify-end\">\n                    <Button onClick={onClose} type=\"button\" variant=\"outline\">\n                      Cancel\n                    </Button>\n                    <Button\n                      className=\"bg-primary hover:bg-primary/90\"\n                      disabled={!url.trim()}\n                      type=\"submit\"\n                    >\n                      Insert Image\n                    </Button>\n                  </div>\n                </form>\n\n                <div className=\"relative\">\n                  <div className=\"absolute inset-0 flex items-center\">\n                    <span className=\"w-full border-t border-border/60\" />\n                  </div>\n                  <div className=\"relative flex justify-center text-xs uppercase\">\n                    <span className=\"bg-background px-2 text-muted-foreground font-medium\">\n                      Or\n                    </span>\n                  </div>\n                </div>\n\n                <div>\n                  <input\n                    accept=\"image/*\"\n                    className=\"hidden\"\n                    onChange={handleFileChange}\n                    ref={fileInputRef}\n                    type=\"file\"\n                  />\n                  <Button\n                    className=\"w-full hover:bg-accent/80 transition-colors bg-transparent\"\n                    onClick={() => fileInputRef.current?.click()}\n                    type=\"button\"\n                    variant=\"outline\"\n                  >\n                    <Upload className=\"size-4 mr-2\" />\n                    Upload from Computer\n                  </Button>\n                </div>\n              </div>\n            </div>\n          </DialogContent>\n        </Dialog>\n      )}\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/components/image-dialog.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/components/index.ts",
      "content": "export * from \"./image-dialog\";\nexport * from \"./link-dialog\";\nexport * from \"./link-popover\";\nexport * from \"./table-dialog\";\n",
      "type": "registry:lib",
      "target": "components/editor/components/index.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/components/link-dialog.tsx",
      "content": "import type React from \"react\";\nimport { useEffect, useState } from \"react\";\n\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/registry/new-york/ui/dialog\";\nimport { Input } from \"@/registry/new-york/ui/input\";\nimport { Label } from \"@/registry/new-york/ui/label\";\n\nexport function LinkDialog({\n  isOpen,\n  onClose,\n  onSubmit,\n  initialUrl = \"\",\n}: {\n  isOpen: boolean;\n  onClose: () => void;\n  onSubmit: (url: string) => void;\n  initialUrl?: string;\n}) {\n  const [url, setUrl] = useState(initialUrl);\n\n  useEffect(() => {\n    if (isOpen) {\n      setUrl(initialUrl);\n    }\n  }, [isOpen, initialUrl]);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (url.trim()) {\n      onSubmit(url.trim());\n    }\n    onClose();\n  };\n\n  return (\n    <>\n      {isOpen && (\n        <Dialog onOpenChange={onClose} open={isOpen}>\n          <DialogContent\n            aria-describedby=\"link-dialog\"\n            className=\"sm:max-w-md backdrop-blur-md bg-background/95\"\n          >\n            <div>\n              <DialogHeader>\n                <DialogTitle className=\"text-xl font-semibold\">\n                  Insert Link\n                </DialogTitle>\n              </DialogHeader>\n              <form className=\"space-y-4 mt-4\" onSubmit={handleSubmit}>\n                <div>\n                  <Label className=\"text-sm font-medium\" htmlFor=\"url\">\n                    URL\n                  </Label>\n                  <Input\n                    autoFocus\n                    className=\"mt-1.5 focus:ring-2 focus:ring-primary/20 transition-all\"\n                    id=\"url\"\n                    onChange={(e) => setUrl(e.target.value)}\n                    placeholder=\"https://example.com\"\n                    value={url}\n                  />\n                </div>\n                <div className=\"flex gap-2 justify-end\">\n                  <Button onClick={onClose} type=\"button\" variant=\"outline\">\n                    Cancel\n                  </Button>\n                  <Button\n                    className=\"bg-primary hover:bg-primary/90\"\n                    type=\"submit\"\n                  >\n                    Insert Link\n                  </Button>\n                </div>\n              </form>\n            </div>\n          </DialogContent>\n        </Dialog>\n      )}\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/components/link-dialog.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/components/table-dialog.tsx",
      "content": "import type React from \"react\";\nimport { useState } from \"react\";\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/registry/new-york/ui/dialog\";\nimport { Input } from \"@/registry/new-york/ui/input\";\nimport { Label } from \"@/registry/new-york/ui/label\";\n\nexport function TableDialog({\n  isOpen,\n  onClose,\n  onSubmit,\n}: {\n  isOpen: boolean;\n  onClose: () => void;\n  onSubmit: (rows: number, columns: number) => void;\n}) {\n  const [rows, setRows] = useState(3);\n  const [columns, setColumns] = useState(3);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSubmit(rows, columns);\n    onClose();\n  };\n\n  return (\n    <>\n      {isOpen && (\n        <Dialog onOpenChange={onClose} open={isOpen}>\n          <DialogContent\n            aria-describedby=\"table-dialog\"\n            className=\"sm:max-w-md backdrop-blur-md bg-background/95\"\n          >\n            <div>\n              <DialogHeader>\n                <DialogTitle className=\"text-xl font-semibold\">\n                  Insert Table\n                </DialogTitle>\n              </DialogHeader>\n              <form className=\"space-y-4 mt-4\" onSubmit={handleSubmit}>\n                <div className=\"grid grid-cols-2 gap-4\">\n                  <div>\n                    <Label className=\"text-sm font-medium\" htmlFor=\"rows\">\n                      Rows\n                    </Label>\n                    <Input\n                      className=\"mt-1.5\"\n                      id=\"rows\"\n                      max=\"20\"\n                      min=\"1\"\n                      onChange={(e) =>\n                        setRows(\n                          Math.max(1, Number.parseInt(e.target.value) || 1),\n                        )\n                      }\n                      type=\"number\"\n                      value={rows}\n                    />\n                  </div>\n                  <div>\n                    <Label className=\"text-sm font-medium\" htmlFor=\"columns\">\n                      Columns\n                    </Label>\n                    <Input\n                      className=\"mt-1.5\"\n                      id=\"columns\"\n                      max=\"20\"\n                      min=\"1\"\n                      onChange={(e) =>\n                        setColumns(\n                          Math.max(1, Number.parseInt(e.target.value) || 1),\n                        )\n                      }\n                      type=\"number\"\n                      value={columns}\n                    />\n                  </div>\n                </div>\n                <div className=\"flex gap-2 justify-end\">\n                  <Button onClick={onClose} type=\"button\" variant=\"outline\">\n                    Cancel\n                  </Button>\n                  <Button\n                    className=\"bg-primary hover:bg-primary/90\"\n                    type=\"submit\"\n                  >\n                    Insert Table\n                  </Button>\n                </div>\n              </form>\n            </div>\n          </DialogContent>\n        </Dialog>\n      )}\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/components/table-dialog.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/components/toolbar-separator.tsx",
      "content": "import { cn } from \"@/registry/new-york/libs/utils\";\n\ninterface Props {\n  orientation?: \"vertical\" | \"horizontal\";\n}\nconst Separator = ({ orientation = \"vertical\" }: Props) => {\n  return (\n    <div\n      className={cn(\n        \"bg-linear-to-b from-transparent via-border to-transparent mx-2\",\n        orientation === \"horizontal\" ? \"h-px w-6 my-2\" : \"w-px h-6 mx-2\",\n      )}\n    />\n  );\n};\n\nexport default Separator;\n",
      "type": "registry:component",
      "target": "components/editor/components/toolbar-separator.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/colors.ts",
      "content": "export const HIGHLIGHT_COLORS = [\n  { name: \"Golden\", value: \"rgba(255, 235, 59, 0.3)\" },\n  { name: \"Emerald\", value: \"rgba(16, 185, 129, 0.3)\" },\n  { name: \"Sky\", value: \"rgba(14, 165, 233, 0.3)\" },\n  { name: \"Rose\", value: \"rgba(244, 63, 94, 0.3)\" },\n  { name: \"Violet\", value: \"rgba(139, 92, 246, 0.3)\" },\n  { name: \"Amber\", value: \"rgba(245, 158, 11, 0.3)\" },\n];\n\nexport const FONT_COLORS = [\n  { name: \"Default\", value: \"hsl(var(--foreground))\" },\n  { name: \"Muted\", value: \"hsl(var(--muted-foreground))\" },\n  { name: \"Slate\", value: \"#64748b\" },\n  { name: \"Amber\", value: \"#f59e0b\" },\n  { name: \"Emerald\", value: \"#10b981\" },\n  { name: \"Blue\", value: \"#3b82f6\" },\n  { name: \"Purple\", value: \"#8b5cf6\" },\n  { name: \"Rose\", value: \"#f43f5a\" },\n  { name: \"Indigo\", value: \"#6366f1\" },\n];\n",
      "type": "registry:lib",
      "target": "components/editor/lib/colors.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/configs.ts",
      "content": "import EditorTheme from \"./editor-theme\";\nimport { nodes } from \"./nodes\";\n\nfunction onError(error: Error) {\n  console.error(\"Lexical error:\", error);\n}\n\nexport const EDITOR_CONFIG = {\n  namespace: \"Editor\",\n  theme: EditorTheme,\n  onError,\n  nodes,\n};\n",
      "type": "registry:lib",
      "target": "components/editor/lib/configs.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/editor-theme/index.ts",
      "content": "import type { EditorThemeClasses } from \"lexical\";\n\nexport const theme: EditorThemeClasses = {\n  ltr: \"text-left\",\n  rtl: \"text-right\",\n\n  paragraph: \"m-0 mb-2 leading-relaxed relative will-change-auto\",\n\n  heading: {\n    h1: \"text-3xl font-bold my-4 text-foreground will-change-auto\",\n    h2: \"text-2xl font-semibold my-3 text-foreground/95 will-change-auto\",\n    h3: \"text-xl font-medium my-3 text-foreground/90 will-change-auto\",\n    h4: \"text-lg font-medium my-2 text-foreground/85 will-change-auto\",\n    h5: \"text-base font-medium my-2 text-foreground/80 will-change-auto\",\n    h6: \"text-sm font-medium my-2 text-foreground/80 will-change-auto\",\n  },\n\n  quote:\n    \"ml-4 my-3 border-l-4 border-muted-foreground/30 pl-4 text-muted-foreground italic bg-muted/20 py-2 rounded-r will-change-auto\",\n\n  list: {\n    nested: {\n      listitem: \"list-none\",\n    },\n    olDepth: [\n      \"list-decimal list-outside ml-6\",\n      \"list-[upper-alpha] list-outside ml-6\",\n      \"list-[lower-alpha] list-outside ml-6\",\n      \"list-[upper-roman] list-outside ml-6\",\n      \"list-[lower-roman] list-outside ml-6\",\n    ],\n    ol: \"list-decimal list-outside my-2 ml-6 space-y-1\",\n    ul: \"list-disc list-outside my-2 ml-6 space-y-1\",\n    listitem: \"pl-2\",\n    listitemChecked:\n      \"relative flex items-center gap-2 list-none outline-none text-muted-foreground before:content-[''] before:flex-shrink-0 before:mt-0.5 before:size-4 before:rounded before:border before:border-primary before:bg-primary before:cursor-pointer before:flex before:items-center before:justify-center before:[content:'âœ“'] before:text-primary-foreground before:text-sm before:font-medium [&>span]:line-through\",\n    listitemUnchecked:\n      \"relative flex items-center gap-2 list-none outline-none before:content-[''] before:flex-shrink-0 before:mt-0.5 before:size-4 before:rounded before:border before:border-border/50 before:bg-muted before:cursor-pointer hover:before:border-border/70\",\n    checklist: \"my-2 space-y-2\",\n  },\n\n  text: {\n    bold: \"font-bold\",\n    capitalize: \"capitalize\",\n    code: \"bg-muted/90 dark:bg-muted/70 mx-0.5 px-1.5 py-0.5 rounded text-sm font-mono border border-border/50 text-foreground/90\",\n    highlight: \"bg-yellow-200/40 dark:bg-yellow-900/30 px-1 rounded\",\n    italic: \"italic\",\n    lowercase: \"lowercase\",\n    strikethrough: \"line-through opacity-70\",\n    subscript: \"text-xs align-sub\",\n    superscript: \"text-xs align-super\",\n    underline: \"underline decoration-2 underline-offset-2\",\n    underlineStrikethrough: \"underline line-through opacity-70\",\n    uppercase: \"uppercase\",\n  },\n\n  code: \"relative block bg-muted/50 dark:bg-muted/30 rounded-lg overflow-x-auto my-4 text-sm leading-relaxed px-4 py-3 font-mono border border-border/50\",\n  codeHighlight: {\n    atrule: \"text-blue-600 dark:text-blue-400\",\n    attr: \"text-blue-600 dark:text-blue-400\",\n    boolean: \"text-purple-600 dark:text-purple-400\",\n    builtin: \"text-green-600 dark:text-green-400\",\n    cdata: \"text-gray-500 dark:text-gray-400\",\n    char: \"text-green-600 dark:text-green-400\",\n    class: \"text-red-600 dark:text-red-400\",\n    \"class-name\": \"text-red-600 dark:text-red-400\",\n    comment: \"text-gray-500 dark:text-gray-400 italic\",\n    constant: \"text-purple-600 dark:text-purple-400\",\n    deleted: \"bg-red-100 dark:bg-red-900/30 border-red-300 dark:border-red-700\",\n    doctype: \"text-gray-500 dark:text-gray-400\",\n    entity: \"text-orange-600 dark:text-orange-400\",\n    function: \"text-red-600 dark:text-red-400\",\n    important: \"text-yellow-600 dark:text-yellow-400 font-bold\",\n    inserted:\n      \"bg-green-100 dark:bg-green-900/30 border-green-300 dark:border-green-700\",\n    keyword: \"text-blue-600 dark:text-blue-400 font-medium\",\n    namespace: \"text-yellow-600 dark:text-yellow-400\",\n    number: \"text-purple-600 dark:text-purple-400\",\n    operator: \"text-orange-600 dark:text-orange-400\",\n    prolog: \"text-gray-500 dark:text-gray-400\",\n    property: \"text-purple-600 dark:text-purple-400\",\n    punctuation: \"text-gray-600 dark:text-gray-300\",\n    regex: \"text-yellow-600 dark:text-yellow-400\",\n    selector: \"text-green-600 dark:text-green-400\",\n    string: \"text-green-600 dark:text-green-400\",\n    symbol: \"text-purple-600 dark:text-purple-400\",\n    tag: \"text-purple-600 dark:text-purple-400\",\n    unchanged:\n      \"bg-gray-100 dark:bg-gray-800 border-gray-300 dark:border-gray-600\",\n    url: \"text-orange-600 dark:text-orange-400 underline\",\n    variable: \"text-yellow-600 dark:text-yellow-400\",\n  },\n\n  link: \"text-editor-accent hover:text-editor-primary/80 underline decoration-primary/50 hover:decoration-editor-primary transition-colors duration-200 cursor-pointer\",\n\n  table:\n    \"border-collapse table-fixed w-full max-w-[80vw] my-4 border border-border rounded-lg overflow-hidden\",\n  tableAddColumns:\n    \"absolute h-full w-5 top-0 -right-5 bg-editor-muted/70 hover:bg-editor-muted cursor-pointer border-0 rounded transition-all duration-200 opacity-0 hover:opacity-100 after:content-['+'] after:absolute after:flex after:items-center after:justify-center after:w-full after:h-full after:text-editor-muted-foreground after:text-lg after:font-bold\",\n  tableAddRows:\n    \"absolute w-full h-5 left-0 -bottom-5 bg-editor-muted/70 hover:bg-editor-muted cursor-pointer border-0 rounded transition-all duration-200 opacity-0 hover:opacity-100 after:content-['+'] after:absolute after:flex after:items-center after:justify-center after:w-full after:h-full after:text-editor-muted-foreground after:text-lg after:font-bold\",\n  tableAlignment: {\n    center: \"mx-auto\",\n    right: \"ml-auto\",\n  },\n  tableCell:\n    \"border border-editor-border/60 p-3 align-top text-left relative outline-none overflow-auto min-w-[7.5rem] bg-editor-background md:min-w-[5rem] md:p-2 md:text-sm\",\n  tableCellActionButton:\n    \"absolute top-0 right-0 z-10 w-6 h-6 bg-editor-background border border-editor-border rounded-bl hover:bg-editor-muted transition-colors duration-200 flex items-center justify-center text-xs text-editor-muted-foreground hover:text-editor-foreground cursor-pointer opacity-0 group-hover:opacity-100\",\n  tableCellActionButtonContainer:\n    \"absolute top-0 right-0 w-6 h-6 pointer-events-auto\",\n  tableCellHeader:\n    \"bg-editor-muted/30 font-semibold text-editor-foreground border-b-2 border-editor-border\",\n  tableCellResizer:\n    \"absolute right-0 top-0 h-full w-1 bg-transparent cursor-col-resize hover:bg-editor-primary/50 transition-colors duration-200\",\n  tableCellSelected: \"bg-editor-primary/10 outline-2 outline-editor-primary\",\n  tableFrozenColumn:\n    \"sticky left-0 z-20 bg-editor-background border-r-2 border-editor-border shadow-sm\",\n  tableFrozenRow:\n    \"sticky top-0 z-10 bg-editor-background border-b-2 border-editor-border shadow-sm\",\n  tableRowStriping: \"even:bg-editor-muted/20 odd:bg-editor-background\",\n  tableScrollableWrapper:\n    \"overflow-x-auto border border-editor-border rounded-lg my-0 mb-6\",\n  tableSelected: \"outline-2 outline-editor-primary\",\n  tableSelection:\n    \"bg-editor-primary/10 border-2 border-editor-primary/50 rounded\",\n\n  hr: \"my-4 border relative after:content-[''] after:block\",\n  hrSelected: \"outline-2 outline-primary rounded select-none\",\n\n  hashtag:\n    \"bg-blue-100/60 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 px-1 rounded-sm font-medium\",\n\n  blockCursor:\n    \"block absolute pointer-events-none after:content-[''] after:absolute after:block after:-top-0.5 after:w-5 after:border-t-2 after:border-foreground after:animate-[cursor-blink_1.1s_steps(2,start)_infinite]\",\n\n  characterLimit: \"bg-red-200 dark:bg-red-900/50\",\n\n  mark: \"bg-yellow-200/40 px-1 rounded\",\n  markOverlap: \"bg-yellow-300/60 px-1 rounded\",\n\n  embedBlock: {\n    base: \"select-none my-2\",\n    focus: \"outline-2 outline-editor-primary rounded\",\n  },\n\n  layoutContainer: \"grid gap-4 my-4\",\n  layoutItem:\n    \"border border-dashed border-border p-4 min-w-0 max-w-full rounded-lg\",\n\n  autocomplete: \"text-editor-muted-foreground bg-muted/50 px-2 py-1 rounded\",\n\n  tab: \"relative inline-block no-underline w-[4ch]\",\n\n  specialText:\n    \"bg-yellow-300/60 dark:bg-yellow-900/40 text-yellow-900 dark:text-yellow-100 px-1 rounded font-medium\",\n\n  image: \"max-w-full h-auto rounded-lg my-4 shadow-sm\",\n  inlineImage: \"inline-block max-h-6 rounded\",\n};\n\nexport default theme;\n",
      "type": "registry:lib",
      "target": "components/editor/lib/editor-theme/index.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/hooks/use-floating-toolbar.ts",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { mergeRegister } from \"@lexical/utils\";\nimport {\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  SELECTION_CHANGE_COMMAND,\n} from \"lexical\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\ninterface Position {\n  top: number;\n  left: number;\n  opacity: number;\n}\n\ninterface UseFloatingToolbarReturn {\n  toolbarRef: React.RefObject<HTMLDivElement | null>;\n  isVisible: boolean;\n  position: Position;\n  activeFormats: Set<string>;\n  selectedText: string;\n}\n\nexport function useFloatingToolbar(): UseFloatingToolbarReturn {\n  const [editor] = useLexicalComposerContext();\n  const toolbarRef = useRef<HTMLDivElement>(null);\n  const timeoutRef = useRef<NodeJS.Timeout>(null);\n\n  const [activeFormats, setActiveFormats] = useState<Set<string>>(new Set());\n  const [isVisible, setIsVisible] = useState(false);\n  const [selectedText, setSelectedText] = useState(\"\");\n  const [position, setPosition] = useState<Position>({\n    top: -1000,\n    left: -1000,\n    opacity: 0,\n  });\n\n  const calculatePosition = useCallback((rect: DOMRect): Position => {\n    const toolbar = toolbarRef.current;\n    if (!toolbar) return { top: -1000, left: -1000, opacity: 0 };\n\n    const toolbarRect = toolbar.getBoundingClientRect();\n    const viewport = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n\n    let top = rect.top + window.scrollY - toolbarRect.height - 10;\n    let left =\n      rect.left + window.scrollX + rect.width / 2 - toolbarRect.width / 2;\n\n    if (left < 10) {\n      left = 10;\n    } else if (left + toolbarRect.width > viewport.width - 10) {\n      left = viewport.width - toolbarRect.width - 10;\n    }\n\n    if (top < window.scrollY + 10) {\n      top = rect.bottom + window.scrollY + 10;\n    }\n\n    return { top, left, opacity: 1 };\n  }, []);\n\n  const FORMATS = [\n    \"bold\",\n    \"italic\",\n    \"underline\",\n    \"code\",\n    \"strikethrough\",\n    \"superscript\",\n    \"subscript\",\n  ] as const;\n\n  const updateToolbar = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n\n    editor.read(() => {\n      const selection = $getSelection();\n\n      if (\n        $isRangeSelection(selection) &&\n        !selection.isCollapsed() &&\n        selection.getTextContent().trim() !== \"\"\n      ) {\n        const nativeSelection = window.getSelection();\n        if (!nativeSelection || nativeSelection.rangeCount === 0) {\n          setIsVisible(false);\n          return;\n        }\n\n        const domRange = nativeSelection.getRangeAt(0);\n        const rect = domRange.getBoundingClientRect();\n        const text = selection.getTextContent().trim();\n\n        if (text.length < 2) {\n          setIsVisible(false);\n          return;\n        }\n\n        setSelectedText(text);\n\n        const formats = new Set<string>();\n        FORMATS.forEach((format) => {\n          if (selection.hasFormat(format)) {\n            formats.add(format);\n          }\n        });\n\n        setActiveFormats(formats);\n        setIsVisible(true);\n\n        requestAnimationFrame(() => {\n          const newPosition = calculatePosition(rect);\n          setPosition((prev) => {\n            if (\n              Math.abs(prev.top - newPosition.top) > 1 ||\n              Math.abs(prev.left - newPosition.left) > 1\n            ) {\n              return newPosition;\n            }\n            return prev;\n          });\n        });\n      } else {\n        timeoutRef.current = setTimeout(() => {\n          setIsVisible(false);\n          setPosition((prev) => ({ ...prev, opacity: 0 }));\n        }, 100);\n      }\n    });\n  }, [editor, calculatePosition]);\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      const target = event.target as Node;\n      const editorRoot = editor.getRootElement();\n\n      if (\n        isVisible &&\n        toolbarRef.current &&\n        !toolbarRef.current.contains(target) &&\n        !editorRoot?.contains(target)\n      ) {\n        setIsVisible(false);\n      }\n    };\n\n    const handleScroll = () => {\n      if (isVisible) {\n        requestAnimationFrame(() => {\n          updateToolbar();\n        });\n      }\n    };\n\n    const handleResize = () => {\n      if (isVisible) {\n        requestAnimationFrame(() => {\n          const nativeSelection = window.getSelection();\n          if (nativeSelection && nativeSelection.rangeCount > 0) {\n            const domRange = nativeSelection.getRangeAt(0);\n            const rect = domRange.getBoundingClientRect();\n            const newPosition = calculatePosition(rect);\n            setPosition((prev) => {\n              if (\n                Math.abs(prev.top - newPosition.top) > 1 ||\n                Math.abs(prev.left - newPosition.left) > 1\n              ) {\n                return newPosition;\n              }\n              return prev;\n            });\n          }\n        });\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    window.addEventListener(\"scroll\", handleScroll, { passive: true });\n    window.addEventListener(\"resize\", handleResize, { passive: true });\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n      window.removeEventListener(\"scroll\", handleScroll);\n      window.removeEventListener(\"resize\", handleResize);\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [editor, isVisible, updateToolbar, calculatePosition]);\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        editorState.read(updateToolbar);\n      }),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          updateToolbar();\n          return false;\n        },\n        COMMAND_PRIORITY_LOW\n      )\n    );\n  }, [editor, updateToolbar]);\n\n  return {\n    toolbarRef,\n    isVisible,\n    position,\n    activeFormats,\n    selectedText,\n  };\n}\n",
      "type": "registry:hook",
      "target": "components/editor/lib/hooks/use-floating-toolbar.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/nodes/image-node.tsx",
      "content": "import { DecoratorNode } from \"lexical\";\nimport Image from \"next/image\";\nimport type { JSX } from \"react\";\n\nimport type { ImageNodeSerialized } from \"../types/editor\";\n\nexport class ImageNode extends DecoratorNode<JSX.Element> {\n  __src: string;\n  __alt: string;\n\n  static getType(): string {\n    return \"image\";\n  }\n\n  static clone(node: ImageNode): ImageNode {\n    return new ImageNode(node.__src, node.__alt, node.__key);\n  }\n\n  static importJSON(serializedNode: ImageNodeSerialized): ImageNode {\n    const { src, alt } = serializedNode;\n    return new ImageNode(src, alt);\n  }\n\n  exportJSON(): ImageNodeSerialized {\n    return {\n      type: \"image\",\n      version: 1,\n      src: this.__src,\n      alt: this.__alt,\n    } as ImageNodeSerialized;\n  }\n\n  constructor(src: string, alt = \"Image\", key?: string) {\n    super(key);\n    this.__src = src;\n    this.__alt = alt;\n  }\n\n  createDOM(): HTMLElement {\n    const div = document.createElement(\"div\");\n    div.className = \"image-node\";\n    return div;\n  }\n\n  updateDOM(): boolean {\n    return false;\n  }\n\n  decorate(): JSX.Element {\n    return (\n      <Image\n        alt={this.__alt}\n        height={500}\n        src={this.__src || \"/placeholder.svg\"}\n        width={500}\n        // onError={() => setIsLoadError(true)}\n      />\n    );\n  }\n}\n\nexport function $createImageNode(src: string, alt?: string): ImageNode {\n  return new ImageNode(src, alt);\n}\n",
      "type": "registry:component",
      "target": "components/editor/lib/nodes/image-node.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/nodes/index.ts",
      "content": "import { CodeHighlightNode, CodeNode } from \"@lexical/code\";\nimport { AutoLinkNode, LinkNode } from \"@lexical/link\";\nimport { ListItemNode, ListNode } from \"@lexical/list\";\nimport { HorizontalRuleNode } from \"@lexical/react/LexicalHorizontalRuleNode\";\nimport { HeadingNode, QuoteNode } from \"@lexical/rich-text\";\nimport { TableCellNode, TableNode, TableRowNode } from \"@lexical/table\";\nimport { ImageNode } from \"./image-node\";\n\nexport const nodes = [\n  HeadingNode,\n  ListNode,\n  ListItemNode,\n  QuoteNode,\n  CodeNode,\n  CodeHighlightNode,\n  LinkNode,\n  AutoLinkNode,\n  HorizontalRuleNode,\n  TableNode,\n  TableCellNode,\n  TableRowNode,\n  ImageNode,\n];\n",
      "type": "registry:lib",
      "target": "components/editor/lib/nodes/index.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/types/editor.ts",
      "content": "import type { SerializedLexicalNode } from \"lexical\";\n\nexport type ImageNodeSerialized = {\n  src: string;\n  alt: string;\n  type: string;\n  version: 1;\n} & SerializedLexicalNode;\n\nexport interface EditorProps {\n  initialValue?: string;\n  placeholder?: string;\n  className?: string;\n  minHeight?: string;\n  maxHeight?: string;\n  showToolbar?: boolean;\n  showFloatingToolbar?: boolean;\n  enableSpeechToText?: boolean;\n  readOnly?: boolean;\n  autoFocus?: boolean;\n  onChange?: (value: string) => void;\n  onBlur?: () => void;\n  onFocus?: () => void;\n  plugins?: React.ComponentType[];\n  theme?: Record<string, string>;\n}\n",
      "type": "registry:lib",
      "target": "components/editor/lib/types/editor.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/utils/export.ts",
      "content": "import { $generateHtmlFromNodes } from \"@lexical/html\";\nimport { $convertToMarkdownString, TRANSFORMERS } from \"@lexical/markdown\";\nimport type { LexicalEditor } from \"lexical\";\nimport { $getRoot } from \"lexical\";\n\nfunction download(filename: string, text: string, mimeType = \"text/plain\") {\n  try {\n    const blob = new Blob([text], { type: mimeType });\n    const url = URL.createObjectURL(blob);\n    const element = document.createElement(\"a\");\n    element.setAttribute(\"href\", url);\n    element.setAttribute(\"download\", filename);\n    element.style.display = \"none\";\n    document.body.appendChild(element);\n    element.click();\n    document.body.removeChild(element);\n    URL.revokeObjectURL(url);\n  } catch (error) {\n    console.error(\"Failed to download file:\", error);\n    const element = document.createElement(\"a\");\n    element.setAttribute(\n      \"href\",\n      `data:${mimeType};charset=utf-8,${encodeURIComponent(text)}`\n    );\n    element.setAttribute(\"download\", filename);\n    element.style.display = \"none\";\n    document.body.appendChild(element);\n    element.click();\n    document.body.removeChild(element);\n  }\n}\n\nexport function exportAsHTML(editor: LexicalEditor) {\n  try {\n    editor.update(() => {\n      const htmlString = $generateHtmlFromNodes(editor, null);\n      if (htmlString) {\n        download(\"editor-content.html\", htmlString, \"text/html\");\n      } else {\n        console.warn(\"No HTML content to export\");\n      }\n    });\n  } catch (error) {\n    console.error(\"Failed to export as HTML:\", error);\n  }\n}\n\nexport function exportAsMarkdown(editor: LexicalEditor) {\n  try {\n    editor.update(() => {\n      const markdown = $convertToMarkdownString(TRANSFORMERS);\n      if (markdown) {\n        download(\"editor-content.md\", markdown, \"text/markdown\");\n      } else {\n        console.warn(\"No markdown content to export\");\n      }\n    });\n  } catch (error) {\n    console.error(\"Failed to export as Markdown:\", error);\n  }\n}\n\nexport async function copyAsPlainText(editor: LexicalEditor) {\n  try {\n    editor.getEditorState().read(() => {\n      const text = $getRoot().getTextContent();\n      if (text) {\n        if (navigator.clipboard && navigator.clipboard.writeText) {\n          navigator.clipboard.writeText(text).catch((error) => {\n            console.error(\"Failed to copy to clipboard:\", error);\n            fallbackCopyTextToClipboard(text);\n          });\n        } else {\n          fallbackCopyTextToClipboard(text);\n        }\n      } else {\n        console.warn(\"No text content to copy\");\n      }\n    });\n  } catch (error) {\n    console.error(\"Failed to copy text:\", error);\n  }\n}\n\nfunction fallbackCopyTextToClipboard(text: string) {\n  const textArea = document.createElement(\"textarea\");\n  textArea.value = text;\n  textArea.style.position = \"fixed\";\n  textArea.style.left = \"-999999px\";\n  textArea.style.top = \"-999999px\";\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n  try {\n    document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(\"Fallback copy failed:\", error);\n  }\n  document.body.removeChild(textArea);\n}\n",
      "type": "registry:lib",
      "target": "components/editor/lib/utils/export.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/utils/import.ts",
      "content": "import { $convertFromMarkdownString, TRANSFORMERS } from \"@lexical/markdown\";\nimport type { LexicalEditor } from \"lexical\";\n\nexport function importMarkdown(editor: LexicalEditor, file: File) {\n  const reader = new FileReader();\n  reader.onload = (e) => {\n    const text = e.target?.result as string;\n    if (text) {\n      editor.update(() => {\n        $convertFromMarkdownString(text, TRANSFORMERS);\n      });\n    }\n  };\n  reader.readAsText(file);\n}\n",
      "type": "registry:lib",
      "target": "components/editor/lib/utils/import.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/lib/utils/index.ts",
      "content": "export * from \"./export\";\nexport * from \"./import\";\n",
      "type": "registry:lib",
      "target": "components/editor/lib/utils/index.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/floating-toolbar/index.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { $patchStyleText } from \"@lexical/selection\";\nimport {\n  $getSelection,\n  $isRangeSelection,\n  FORMAT_TEXT_COMMAND,\n  type TextFormatType,\n} from \"lexical\";\nimport {\n  Bold,\n  Code,\n  Highlighter,\n  Italic,\n  type LucideIcon,\n  Palette,\n  Strikethrough,\n  Subscript,\n  Superscript,\n  Underline,\n} from \"lucide-react\";\nimport { useCallback, useMemo } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport {\n  Menu,\n  MenuItem,\n  MenuPopup,\n  MenuSeparator,\n  MenuTrigger,\n} from \"@/registry/new-york/ui/menu\";\nimport Separator from \"../../components/toolbar-separator\";\nimport { HIGHLIGHT_COLORS } from \"../../lib/colors\";\nimport { useFloatingToolbar } from \"../../lib/hooks/use-floating-toolbar\";\nimport {\n  ToolbarButton,\n  ToolbarToggleButton,\n} from \"../toolbar/extensions/toolbar-button\";\n\ninterface FormatItem {\n  name: string;\n  icon: LucideIcon;\n  format: string;\n  group: \"basic\" | \"script\" | \"special\";\n}\n\nconst FORMAT_ITEMS: FormatItem[] = [\n  { name: \"Bold\", icon: Bold, format: \"bold\", group: \"basic\" },\n  { name: \"Italic\", icon: Italic, format: \"italic\", group: \"basic\" },\n  { name: \"Underline\", icon: Underline, format: \"underline\", group: \"basic\" },\n  {\n    name: \"Strikethrough\",\n    icon: Strikethrough,\n    format: \"strikethrough\",\n    group: \"basic\",\n  },\n  { name: \"Code\", icon: Code, format: \"code\", group: \"special\" },\n  {\n    name: \"Superscript\",\n    icon: Superscript,\n    format: \"superscript\",\n    group: \"script\",\n  },\n  { name: \"Subscript\", icon: Subscript, format: \"subscript\", group: \"script\" },\n];\n\nexport function FloatingToolbar() {\n  const [editor] = useLexicalComposerContext();\n  const { toolbarRef, isVisible, position, activeFormats, selectedText } =\n    useFloatingToolbar();\n\n  const formatText = useCallback(\n    (format: string) => {\n      editor.dispatchCommand(FORMAT_TEXT_COMMAND, format as TextFormatType);\n      editor.focus();\n    },\n    [editor],\n  );\n\n  const formatHighlight = useCallback(\n    (color: string) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $patchStyleText(selection, {\n            \"background-color\": color || \"transparent\",\n          });\n        }\n      });\n      editor.focus();\n    },\n    [editor],\n  );\n\n  const groupedItems = useMemo(() => {\n    const groups = FORMAT_ITEMS.reduce(\n      (acc, item) => {\n        if (!acc[item.group]) acc[item.group] = [];\n        acc[item.group].push(item);\n        return acc;\n      },\n      {} as Record<string, FormatItem[]>,\n    );\n\n    return groups;\n  }, []);\n\n  if (!isVisible) return null;\n\n  return createPortal(\n    <div\n      className=\"absolute z-50 flex items-center gap-1 p-2 bg-popover/95 backdrop-blur-md border border-border/50 rounded-lg shadow-lg transition-opacity duration-200 ease-out will-change-[opacity,transform]\"\n      ref={toolbarRef}\n      style={{\n        top: `${position.top}px`,\n        left: `${position.left}px`,\n        opacity: position.opacity,\n        transform: `translateZ(0) ${position.opacity === 1 ? \"scale(1)\" : \"scale(0.95)\"}`,\n        pointerEvents: position.opacity > 0 ? \"auto\" : \"none\",\n      }}\n    >\n      {groupedItems.basic?.map((item) => (\n        <ToolbarToggleButton\n          icon={item.icon}\n          isActive={activeFormats.has(item.format)}\n          key={item.name}\n          onClick={() => formatText(item.format)}\n          title={item.name}\n        />\n      ))}\n\n      <Separator />\n\n      {groupedItems.special?.map((item) => (\n        <ToolbarToggleButton\n          icon={item.icon}\n          isActive={activeFormats.has(item.format)}\n          key={item.name}\n          onClick={() => formatText(item.format)}\n          title={item.name}\n        />\n      ))}\n\n      <Separator />\n\n      {groupedItems.script?.map((item) => (\n        <ToolbarToggleButton\n          icon={item.icon}\n          isActive={activeFormats.has(item.format)}\n          key={item.name}\n          onClick={() => formatText(item.format)}\n          title={item.name}\n        />\n      ))}\n\n      <Separator />\n\n      <Menu>\n        <MenuTrigger\n          render={<ToolbarButton icon={Highlighter} title=\"Highlight\" />}\n        />\n        <MenuPopup\n          align=\"center\"\n          className=\"w-48 animate-in slide-in-from-top-2 duration-200\"\n        >\n          <div className=\"grid grid-cols-3 gap-1 p-2\">\n            {HIGHLIGHT_COLORS.map((color) => (\n              <button\n                className=\"flex flex-col items-center gap-1 p-2 rounded hover:bg-muted/50 transition-colors\"\n                key={color.value}\n                onClick={() => formatHighlight(color.value)}\n                title={color.name}\n                type=\"button\"\n              >\n                <div\n                  className=\"w-6 h-4 rounded border border-border/50 shadow-sm\"\n                  style={{ backgroundColor: color.value }}\n                />\n                <span className=\"text-xs text-muted-foreground\">\n                  {color.name}\n                </span>\n              </button>\n            ))}\n          </div>\n          <MenuSeparator />\n          <MenuItem\n            className=\"flex items-center gap-2\"\n            onClick={() => formatHighlight(\"\")}\n          >\n            <Palette className=\"size-4\" />\n            Remove Highlight\n          </MenuItem>\n        </MenuPopup>\n      </Menu>\n\n      {selectedText.length > 50 && (\n        <>\n          <Separator />\n          <div className=\"text-xs text-muted-foreground px-2\">\n            {selectedText.length} chars\n          </div>\n        </>\n      )}\n    </div>,\n    document.body,\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/floating-toolbar/index.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/slash-command/index.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport {\n  LexicalTypeaheadMenuPlugin,\n  MenuOption,\n  useBasicTypeaheadTriggerMatch,\n} from \"@lexical/react/LexicalTypeaheadMenuPlugin\";\nimport type { TextNode } from \"lexical\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { SLASH_COMMANDS, type SlashCommand } from \"./slash-command-items\";\nimport { SlashCommandMenuItem } from \"./slash-command-menu-item\";\n\nclass SlashCommandOption extends MenuOption {\n  command: SlashCommand;\n\n  constructor(command: SlashCommand) {\n    super(command.title);\n    this.command = command;\n  }\n}\n\nexport default function SlashCommandPlugin() {\n  const [editor] = useLexicalComposerContext();\n  const [query, setQuery] = useState<string | null>(null);\n\n  const triggerFn = useBasicTypeaheadTriggerMatch(\"/\", { minLength: 0 });\n\n  const options = useMemo(() => {\n    const filteredCommands = query\n      ? SLASH_COMMANDS.filter(\n          (cmd) =>\n            cmd.title.toLowerCase().includes(query.toLowerCase()) ||\n            cmd.keywords.some((keyword) =>\n              keyword.toLowerCase().includes(query.toLowerCase()),\n            ),\n        )\n      : SLASH_COMMANDS;\n\n    return filteredCommands.map((cmd) => new SlashCommandOption(cmd));\n  }, [query]);\n\n  const onSelectOption = useCallback(\n    (\n      option: SlashCommandOption,\n      nodeToRemove: TextNode | null,\n      closeMenu: () => void,\n    ) => {\n      editor.update(() => {\n        nodeToRemove?.remove();\n        option.command.action(editor);\n        closeMenu();\n      });\n    },\n    [editor],\n  );\n\n  return (\n    <div>\n      <LexicalTypeaheadMenuPlugin\n      menuRenderFn={(\n        anchorElementRef,\n        { selectedIndex, selectOptionAndCleanUp, setHighlightedIndex },\n      ) => {\n        const anchorElement = anchorElementRef.current;\n\n        if (!anchorElement || options.length === 0) {\n          return null;\n        }\n\n        const rect = anchorElement.getBoundingClientRect();\n\n        return createPortal(\n          <div\n            className=\"mt-1 absolute z-50 w-44 max-h-(--available-height) min-w-32 origin-(--transform-origin) overflow-x-hidden overflow-y-auto rounded-md border bg-popover p-1 shadow-md\"\n            style={{\n              top: rect.bottom + window.scrollY + 1,\n              left: rect.left + window.scrollX,\n            }}\n          >\n            {options.map((option, i) => (\n              <SlashCommandMenuItem\n                command={option.command}\n                isSelected={selectedIndex === i}\n                key={option.key}\n                onClick={() => {\n                  setHighlightedIndex(i);\n                  selectOptionAndCleanUp(option);\n                }}\n                onMouseEnter={() => {\n                  setHighlightedIndex(i);\n                }}\n              />\n            ))}\n          </div>,\n          document.body,\n        );\n      }}\n      onQueryChange={setQuery}\n      onSelectOption={onSelectOption}\n      options={options}\n      triggerFn={triggerFn}\n    />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/slash-command/index.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/slash-command/slash-command-items.ts",
      "content": "import { $createCodeNode } from \"@lexical/code\";\nimport {\n  INSERT_CHECK_LIST_COMMAND,\n  INSERT_ORDERED_LIST_COMMAND,\n  INSERT_UNORDERED_LIST_COMMAND,\n} from \"@lexical/list\";\nimport { INSERT_HORIZONTAL_RULE_COMMAND } from \"@lexical/react/LexicalHorizontalRuleNode\";\nimport { $createHeadingNode, $createQuoteNode } from \"@lexical/rich-text\";\nimport { $setBlocksType } from \"@lexical/selection\";\nimport {\n  $createParagraphNode,\n  $getSelection,\n  $isRangeSelection,\n  type LexicalEditor,\n} from \"lexical\";\nimport {\n  CodeSquare,\n  Heading1,\n  Heading2,\n  Heading3,\n  List,\n  ListChecks,\n  ListOrdered,\n  Minus,\n  Quote,\n  Type,\n} from \"lucide-react\";\n\nexport interface SlashCommand {\n  title: string;\n  icon: React.ComponentType<{ className?: string }>;\n  action: (editor: LexicalEditor) => void;\n  keywords: string[];\n}\n\nexport const SLASH_COMMANDS: SlashCommand[] = [\n  {\n    title: \"Text\",\n    icon: Type,\n    action: (editor) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $setBlocksType(selection, () => $createParagraphNode());\n        }\n      });\n    },\n    keywords: [\"paragraph\", \"p\", \"text\"],\n  },\n  {\n    title: \"Heading 1\",\n    icon: Heading1,\n    action: (editor) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $setBlocksType(selection, () => $createHeadingNode(\"h1\"));\n        }\n      });\n    },\n    keywords: [\"heading\", \"h1\"],\n  },\n  {\n    title: \"Heading 2\",\n    icon: Heading2,\n    action: (editor) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $setBlocksType(selection, () => $createHeadingNode(\"h2\"));\n        }\n      });\n    },\n    keywords: [\"heading\", \"h2\"],\n  },\n  {\n    title: \"Heading 3\",\n    icon: Heading3,\n    action: (editor) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $setBlocksType(selection, () => $createHeadingNode(\"h3\"));\n        }\n      });\n    },\n    keywords: [\"heading\", \"h3\"],\n  },\n  {\n    title: \"Bulleted List\",\n    icon: List,\n    action: (editor) => {\n      editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined);\n    },\n    keywords: [\"list\", \"bulleted\", \"ul\"],\n  },\n  {\n    title: \"Numbered List\",\n    icon: ListOrdered,\n    action: (editor) => {\n      editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined);\n    },\n    keywords: [\"list\", \"numbered\", \"ol\"],\n  },\n  {\n    title: \"Check List\",\n    icon: ListChecks,\n    action: (editor) => {\n      editor.dispatchCommand(INSERT_CHECK_LIST_COMMAND, undefined);\n    },\n    keywords: [\"list\", \"check\", \"todo\"],\n  },\n  {\n    title: \"Quote\",\n    icon: Quote,\n    action: (editor) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $setBlocksType(selection, () => $createQuoteNode());\n        }\n      });\n    },\n    keywords: [\"quote\", \"blockquote\"],\n  },\n  {\n    title: \"Code Block\",\n    icon: CodeSquare,\n    action: (editor) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $setBlocksType(selection, () => $createCodeNode());\n        }\n      });\n    },\n    keywords: [\"code\", \"codeblock\"],\n  },\n  {\n    title: \"Divider\",\n    icon: Minus,\n    action: (editor) => {\n      editor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND, undefined);\n    },\n    keywords: [\"divider\", \"hr\", \"horizontal rule\"],\n  },\n];\n",
      "type": "registry:lib",
      "target": "components/editor/plugins/slash-command/slash-command-items.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/slash-command/slash-command-menu-item.tsx",
      "content": "import { cn } from \"@/registry/new-york/libs/utils\";\nimport type { SlashCommand } from \"./slash-command-items\";\n\ninterface SlashCommandMenuItemProps {\n  command: SlashCommand;\n  isSelected: boolean;\n  onClick: () => void;\n  onMouseEnter: () => void;\n}\n\nexport function SlashCommandMenuItem({\n  command,\n  isSelected,\n  onClick,\n  onMouseEnter,\n}: SlashCommandMenuItemProps) {\n  const Icon = command.icon;\n  return (\n    <li className={`flex items-center group rounded`} tabIndex={-1}>\n      <button\n        className={cn(\n          \"flex items-center group gap-3 p-2 rounded cursor-pointer transition-colors\",\n          \"w-full appearance-none\",\n          isSelected ? \"bg-muted\" : \"hover:bg-muted/50\",\n        )}\n        onClick={onClick}\n        onMouseEnter={onMouseEnter}\n        type=\"button\"\n      >\n        <Icon className=\"size-4 text-popover-foreground/80 group-hover:text-popover-foreground\" />\n        <span className=\"text-sm text-popover-foreground/80 group-hover:text-popover-foreground\">\n          {command.title}\n        </span>\n      </button>\n    </li>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/slash-command/slash-command-menu-item.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/speech-to-text/index.tsx",
      "content": "\"use client\";\n\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport {\n  $createParagraphNode,\n  $getRoot,\n  $getSelection,\n  $isRangeSelection,\n  $isTextNode,\n  REDO_COMMAND,\n  UNDO_COMMAND,\n} from \"lexical\";\nimport { Mic, MicOff, Loader2 } from \"lucide-react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/registry/new-york/ui/tooltip\";\n\n// ==================== Type Definitions ====================\n\ninterface SpeechRecognitionAlternative {\n  transcript: string;\n  confidence: number;\n}\n\ninterface SpeechRecognitionResult {\n  readonly isFinal: boolean;\n  readonly length: number;\n  item(index: number): SpeechRecognitionAlternative;\n  [index: number]: SpeechRecognitionAlternative;\n}\n\ninterface SpeechRecognitionResultList {\n  readonly length: number;\n  item(index: number): SpeechRecognitionResult;\n  [index: number]: SpeechRecognitionResult;\n}\n\ninterface SpeechRecognitionEvent extends Event {\n  readonly resultIndex: number;\n  readonly results: SpeechRecognitionResultList;\n}\n\ninterface SpeechRecognitionErrorEvent extends Event {\n  readonly error:\n    | \"no-speech\"\n    | \"aborted\"\n    | \"audio-capture\"\n    | \"network\"\n    | \"not-allowed\"\n    | \"service-not-allowed\"\n    | \"bad-grammar\"\n    | \"language-not-supported\";\n  readonly message: string;\n}\n\ninterface SpeechRecognition extends EventTarget {\n  continuous: boolean;\n  interimResults: boolean;\n  lang: string;\n  maxAlternatives: number;\n  start(): void;\n  stop(): void;\n  abort(): void;\n  onresult: ((event: SpeechRecognitionEvent) => void) | null;\n  onerror: ((event: SpeechRecognitionErrorEvent) => void) | null;\n  onend: (() => void) | null;\n  onspeechstart: (() => void) | null;\n  onspeechend: (() => void) | null;\n  onaudiostart: (() => void) | null;\n  onaudioend: (() => void) | null;\n}\n\ninterface SpeechRecognitionConstructor {\n  new (): SpeechRecognition;\n}\n\ndeclare global {\n  interface Window {\n    SpeechRecognition: SpeechRecognitionConstructor;\n    webkitSpeechRecognition: SpeechRecognitionConstructor;\n  }\n}\n\n// ==================== Voice Commands ====================\n\nconst VOICE_COMMANDS: Record<string, string> = {\n  \"new line\": \"\\n\",\n  newline: \"\\n\",\n  \"new paragraph\": \"\\n\\n\",\n  period: \".\",\n  \"full stop\": \".\",\n  comma: \",\",\n  \"question mark\": \"?\",\n  \"exclamation mark\": \"!\",\n  \"exclamation point\": \"!\",\n  colon: \":\",\n  semicolon: \";\",\n  \"open quote\": '\"',\n  \"close quote\": '\"',\n  \"open parenthesis\": \"(\",\n  \"close parenthesis\": \")\",\n  dash: \"-\",\n  hyphen: \"-\",\n};\n\n// ==================== Global State Management ====================\n\nlet globalIsListening = false;\nlet globalIsProcessing = false;\nconst listeners = new Set<\n  (state: { isListening: boolean; isProcessing: boolean }) => void\n>();\n\nfunction setGlobalState(isListening: boolean, isProcessing: boolean) {\n  globalIsListening = isListening;\n  globalIsProcessing = isProcessing;\n  listeners.forEach((listener) => listener({ isListening, isProcessing }));\n}\n\nexport function useSpeechToTextState() {\n  const [state, setState] = useState({\n    isListening: globalIsListening,\n    isProcessing: globalIsProcessing,\n  });\n\n  useEffect(() => {\n    setState({\n      isListening: globalIsListening,\n      isProcessing: globalIsProcessing,\n    });\n\n    const listener = (newState: {\n      isListening: boolean;\n      isProcessing: boolean;\n    }) => {\n      setState(newState);\n    };\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n    };\n  }, []);\n\n  return state;\n}\n\n// ==================== Text Processing Utilities ====================\n\nfunction capitalizeFirstLetter(text: string): string {\n  return text.charAt(0).toUpperCase() + text.slice(1);\n}\n\nfunction formatTranscript(\n  transcript: string,\n  isStartOfSentence: boolean\n): string {\n  let result = transcript.trim();\n\n  const lowerResult = result.toLowerCase();\n  for (const [command, replacement] of Object.entries(VOICE_COMMANDS)) {\n    if (lowerResult === command) {\n      return replacement;\n    }\n  }\n\n  if (isStartOfSentence && result.length > 0) {\n    result = capitalizeFirstLetter(result);\n  }\n\n  return result;\n}\n\nfunction isAtSentenceStart(text: string): boolean {\n  if (!text || text.length === 0) return true;\n  const trimmed = text.trimEnd();\n  if (trimmed.length === 0) return true;\n  const lastChar = trimmed[trimmed.length - 1];\n  return [\".\", \"!\", \"?\", \"\\n\"].includes(lastChar);\n}\n\n// ==================== Main Plugin Component ====================\n\nexport default function SpeechToTextPlugin() {\n  const [editor] = useLexicalComposerContext();\n  const [isListening, setIsListening] = useState(false);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [isSupported, setIsSupported] = useState(false);\n  const [interimText, setInterimText] = useState(\"\");\n  const [statusMessage, setStatusMessage] = useState(\"\");\n\n  const recognitionRef = useRef<SpeechRecognition | null>(null);\n  const isRunningRef = useRef(false);\n  const shouldBeListeningRef = useRef(false);\n  const isRestartingRef = useRef(false);\n  const restartTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const silenceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  const clearTimeouts = useCallback(() => {\n    if (restartTimeoutRef.current) {\n      clearTimeout(restartTimeoutRef.current);\n      restartTimeoutRef.current = null;\n    }\n    if (silenceTimeoutRef.current) {\n      clearTimeout(silenceTimeoutRef.current);\n      silenceTimeoutRef.current = null;\n    }\n  }, []);\n\n  // Insert text into the editor - simplified and more robust\n  const insertTextIntoEditor = useCallback(\n    (text: string) => {\n      if (!text.trim()) return;\n\n      editor.update(() => {\n        // First, ensure we have a valid selection\n        let selection = $getSelection();\n\n        // If no selection, create one at the end of the document\n        if (!selection || !$isRangeSelection(selection)) {\n          const root = $getRoot();\n          let lastChild = root.getLastChild();\n\n          // If root is empty, create a paragraph\n          if (!lastChild) {\n            const paragraph = $createParagraphNode();\n            root.append(paragraph);\n            lastChild = paragraph;\n          }\n\n          // Select at the end\n          lastChild.selectEnd();\n          selection = $getSelection();\n        }\n\n        if (!$isRangeSelection(selection)) {\n          console.warn(\"Could not get a valid selection\");\n          return;\n        }\n\n        // Determine if we're at the start of a sentence\n        let isStartOfSentence = true;\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n\n        if ($isTextNode(anchorNode)) {\n          const textContent = anchorNode.getTextContent();\n          const offset = anchor.offset;\n          const textBefore = textContent.slice(0, offset);\n          isStartOfSentence = isAtSentenceStart(textBefore);\n        } else {\n          // Check if there's any text in the root\n          const root = $getRoot();\n          const allText = root.getTextContent();\n          isStartOfSentence = isAtSentenceStart(allText);\n        }\n\n        // Format and insert\n        const formattedText = formatTranscript(text, isStartOfSentence);\n        const textToInsert = formattedText + \" \";\n\n        selection.insertText(textToInsert);\n      });\n    },\n    [editor]\n  );\n\n  // Handle editor commands (undo/redo)\n  const handleEditorCommand = useCallback(\n    (command: string): boolean => {\n      const lowerCommand = command.toLowerCase().trim();\n\n      if (lowerCommand === \"undo\") {\n        editor.dispatchCommand(UNDO_COMMAND, undefined);\n        setStatusMessage(\"Undo\");\n        setTimeout(() => setStatusMessage(\"\"), 1500);\n        return true;\n      }\n\n      if (lowerCommand === \"redo\") {\n        editor.dispatchCommand(REDO_COMMAND, undefined);\n        setStatusMessage(\"Redo\");\n        setTimeout(() => setStatusMessage(\"\"), 1500);\n        return true;\n      }\n\n      return false;\n    },\n    [editor]\n  );\n\n  // Start recognition safely\n  const startRecognition = useCallback(() => {\n    if (!recognitionRef.current) return false;\n\n    // Don't start if already running\n    if (isRunningRef.current) {\n      console.debug(\"Recognition already running, skipping start\");\n      return true;\n    }\n\n    try {\n      recognitionRef.current.start();\n      isRunningRef.current = true;\n      return true;\n    } catch (error) {\n      // Check if error is because it's already running\n      if (error instanceof Error && error.message.includes(\"already started\")) {\n        console.debug(\"Recognition was already started\");\n        isRunningRef.current = true;\n        return true;\n      }\n      console.error(\"Failed to start recognition:\", error);\n      isRunningRef.current = false;\n      return false;\n    }\n  }, []);\n\n  // Stop recognition safely\n  const stopRecognition = useCallback(() => {\n    if (!recognitionRef.current) return;\n\n    shouldBeListeningRef.current = false;\n    clearTimeouts();\n\n    try {\n      recognitionRef.current.stop();\n    } catch {\n      // Ignore errors when stopping\n    }\n\n    // Note: isRunningRef will be set to false in the onend handler\n  }, [clearTimeouts]);\n\n  // Initialize speech recognition\n  useEffect(() => {\n    const SpeechRecognition =\n      window.SpeechRecognition || window.webkitSpeechRecognition;\n\n    if (!SpeechRecognition) {\n      console.warn(\"Speech recognition is not supported in this browser\");\n      return;\n    }\n\n    setIsSupported(true);\n\n    const recognition = new SpeechRecognition();\n    recognition.continuous = true;\n    recognition.interimResults = true;\n    recognition.lang = \"en-US\";\n    recognition.maxAlternatives = 3;\n\n    // Handle results\n    recognition.onresult = (event: SpeechRecognitionEvent) => {\n      // Reset silence timeout on any result\n      if (silenceTimeoutRef.current) {\n        clearTimeout(silenceTimeoutRef.current);\n      }\n\n      let interimTranscript = \"\";\n      let finalTranscript = \"\";\n\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const result = event.results[i];\n        const transcript = result[0].transcript;\n\n        if (result.isFinal) {\n          finalTranscript += transcript;\n        } else {\n          interimTranscript += transcript;\n        }\n      }\n\n      // Update interim text display\n      setInterimText(interimTranscript);\n\n      // Process final transcript\n      if (finalTranscript.trim()) {\n        setIsProcessing(true);\n        setGlobalState(true, true);\n\n        const trimmedTranscript = finalTranscript.trim();\n\n        // Check for editor commands first\n        if (!handleEditorCommand(trimmedTranscript)) {\n          // Not a command, insert as text\n          insertTextIntoEditor(trimmedTranscript);\n        }\n\n        // Clear interim after final result\n        setInterimText(\"\");\n        setIsProcessing(false);\n        setGlobalState(globalIsListening, false);\n      }\n\n      // Set silence timeout - restart recognition if stuck\n      silenceTimeoutRef.current = setTimeout(() => {\n        if (shouldBeListeningRef.current && recognitionRef.current) {\n          console.debug(\"Silence timeout - restarting recognition\");\n          isRestartingRef.current = true;\n          try {\n            recognitionRef.current.stop();\n          } catch {}\n        }\n      }, 8000);\n    };\n\n    recognition.onspeechstart = () => {\n      setStatusMessage(\"Listening...\");\n    };\n    recognition.onspeechend = () => {\n      setStatusMessage(\"\");\n    };\n\n    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n      console.debug(\"Speech recognition error:\", event.error);\n\n      switch (event.error) {\n        case \"aborted\":\n          return;\n\n        case \"no-speech\":\n          setStatusMessage(\"No speech detected\");\n          setTimeout(() => setStatusMessage(\"\"), 2000);\n          return;\n\n        case \"audio-capture\":\n          setStatusMessage(\"Microphone error\");\n          setTimeout(() => setStatusMessage(\"\"), 2000);\n          return;\n\n        case \"network\":\n          setStatusMessage(\"Network error\");\n          setTimeout(() => setStatusMessage(\"\"), 2000);\n          return;\n\n        case \"not-allowed\":\n        case \"service-not-allowed\":\n          setStatusMessage(\"Microphone access denied\");\n          shouldBeListeningRef.current = false;\n          isRunningRef.current = false;\n          setIsListening(false);\n          setGlobalState(false, false);\n          setTimeout(() => setStatusMessage(\"\"), 3000);\n          return;\n\n        default:\n          setStatusMessage(`Error: ${event.error}`);\n          setTimeout(() => setStatusMessage(\"\"), 3000);\n      }\n    };\n\n    // Handle recognition end - this is where we track actual running state\n    recognition.onend = () => {\n      console.debug(\"Recognition ended\");\n      isRunningRef.current = false;\n\n      // Clear interim text\n      setInterimText(\"\");\n\n      // Restart if we should still be listening\n      if (shouldBeListeningRef.current) {\n        isRestartingRef.current = true;\n\n        restartTimeoutRef.current = setTimeout(() => {\n          isRestartingRef.current = false;\n\n          if (shouldBeListeningRef.current && recognitionRef.current) {\n            try {\n              recognitionRef.current.start();\n              isRunningRef.current = true;\n              console.debug(\"Recognition restarted\");\n            } catch (error) {\n              console.debug(\"Failed to restart recognition:\", error);\n              // If it fails because already running, that's fine\n              if (\n                error instanceof Error &&\n                error.message.includes(\"already started\")\n              ) {\n                isRunningRef.current = true;\n              } else {\n                shouldBeListeningRef.current = false;\n                setIsListening(false);\n                setGlobalState(false, false);\n              }\n            }\n          }\n        }, 300);\n      } else {\n        // Fully stopped\n        setIsListening(false);\n        setGlobalState(false, false);\n      }\n    };\n\n    recognitionRef.current = recognition;\n\n    // Cleanup\n    return () => {\n      clearTimeouts();\n      shouldBeListeningRef.current = false;\n      if (recognitionRef.current) {\n        try {\n          recognitionRef.current.abort();\n        } catch {\n          // Ignore\n        }\n      }\n      isRunningRef.current = false;\n    };\n  }, [insertTextIntoEditor, handleEditorCommand, clearTimeouts]);\n\n  // Toggle listening state\n  const toggleListening = useCallback(() => {\n    if (!recognitionRef.current) return;\n\n    // Check current actual state, not just React state\n    const currentlyRunning =\n      isRunningRef.current || shouldBeListeningRef.current;\n\n    if (!currentlyRunning) {\n      // Starting\n      clearTimeouts();\n      isRestartingRef.current = false;\n      shouldBeListeningRef.current = true;\n\n      const started = startRecognition();\n      if (started) {\n        setIsListening(true);\n        setGlobalState(true, false);\n        setStatusMessage(\"Starting...\");\n        setTimeout(() => setStatusMessage(\"\"), 1500);\n      } else {\n        shouldBeListeningRef.current = false;\n        setIsListening(false);\n        setGlobalState(false, false);\n        setStatusMessage(\"Failed to start\");\n        setTimeout(() => setStatusMessage(\"\"), 2000);\n      }\n    } else {\n      // Stopping\n      stopRecognition();\n      setInterimText(\"\");\n      setStatusMessage(\"\");\n      setIsListening(false);\n      setGlobalState(false, false);\n    }\n  }, [clearTimeouts, startRecognition, stopRecognition]);\n\n  // Listen for external toggle events (from toolbar)\n  useEffect(() => {\n    const handleToggle = () => {\n      toggleListening();\n    };\n\n    window.addEventListener(\"toggle-speech-to-text\", handleToggle);\n    return () => {\n      window.removeEventListener(\"toggle-speech-to-text\", handleToggle);\n    };\n  }, [toggleListening]);\n\n  // Sync local state with global state\n  useEffect(() => {\n    const listener = (state: {\n      isListening: boolean;\n      isProcessing: boolean;\n    }) => {\n      setIsListening(state.isListening);\n      setIsProcessing(state.isProcessing);\n    };\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n    };\n  }, []);\n\n  if (!isSupported) {\n    return null;\n  }\n\n  return createPortal(\n    <div className=\"fixed bottom-4 right-4 z-50 flex flex-col items-end gap-2\">\n      {/* Status/Interim text display */}\n      {(statusMessage || interimText) && (\n        <div className=\"bg-background/95 backdrop-blur-sm border rounded-lg px-3 py-2 shadow-lg max-w-xs\">\n          {statusMessage && (\n            <div className=\"text-sm text-muted-foreground\">{statusMessage}</div>\n          )}\n          {interimText && (\n            <div className=\"text-sm text-muted-foreground/70 italic\">\n              {interimText}...\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Main button */}\n      <Tooltip>\n        <TooltipTrigger\n          render={\n            <Button\n              onClick={toggleListening}\n              size=\"icon\"\n              variant={isListening ? \"default\" : \"outline\"}\n              className={`rounded-full shadow-lg transition-all duration-300 ${\n                isListening\n                  ? \"bg-destructive hover:bg-destructive/90 scale-110\"\n                  : \"bg-background hover:bg-accent\"\n              } ${isProcessing ? \"ring-2 ring-primary ring-offset-2\" : \"\"}`}\n              aria-label={isListening ? \"Stop recording\" : \"Start recording\"}\n            >\n              {isProcessing ? (\n                <Loader2 className=\"h-4 w-4 animate-spin\" />\n              ) : isListening ? (\n                <MicOff className=\"h-4 w-4\" />\n              ) : (\n                <Mic className=\"h-4 w-4\" />\n              )}\n            </Button>\n          }\n        />\n        <TooltipContent side=\"left\">\n          <p>\n            {isListening ? \"Stop speech-to-text\" : \"Start speech-to-text\"}\n            {isListening && (\n              <span className=\"block text-xs text-muted-foreground mt-1\">\n                Say &quot;undo&quot; or &quot;redo&quot; for commands\n              </span>\n            )}\n          </p>\n        </TooltipContent>\n      </Tooltip>\n    </div>,\n    document.body\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/speech-to-text/index.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/table-hover-actions/index.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport {\n  $deleteTableColumnAtSelection,\n  $deleteTableRowAtSelection,\n  $insertTableColumnAtSelection,\n  $insertTableRowAtSelection,\n  $isTableCellNode,\n  $isTableNode,\n  $isTableRowNode,\n  type TableNode,\n} from \"@lexical/table\";\nimport { $getNearestNodeFromDOMNode, $getNodeByKey } from \"lexical\";\nimport { MoreHorizontal } from \"lucide-react\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport {\n  Menu,\n  MenuItem,\n  MenuPopup,\n  MenuSeparator,\n  MenuTrigger,\n} from \"@/registry/new-york/ui/menu\";\n\nexport default function TableHoverActionsPlugin() {\n  const [editor] = useLexicalComposerContext();\n  const [hoveredTable, setHoveredTable] = useState<{\n    node: TableNode;\n    dom: HTMLElement;\n  } | null>(null);\n  const actionButtonRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const handlePointerMove = (event: PointerEvent) => {\n      const target = event.target as HTMLElement;\n      const table = target.closest(\"table\");\n\n      if (table) {\n        editor.update(() => {\n          const tableNode = $getNearestNodeFromDOMNode(table);\n          if (tableNode && $isTableNode(tableNode)) {\n            setHoveredTable({ node: tableNode, dom: table });\n          } else {\n            setHoveredTable(null);\n          }\n        });\n      } else {\n        setHoveredTable(null);\n      }\n    };\n\n    const editorRoot = editor.getRootElement();\n    editorRoot?.addEventListener(\"pointermove\", handlePointerMove);\n\n    return () => {\n      editorRoot?.removeEventListener(\"pointermove\", handlePointerMove);\n    };\n  }, [editor]);\n\n  useEffect(() => {\n    if (hoveredTable && actionButtonRef.current) {\n      const { dom } = hoveredTable;\n      const rect = dom.getBoundingClientRect();\n      const actionButton = actionButtonRef.current;\n      actionButton.style.top = `${rect.top + window.scrollY - 20}px`;\n      actionButton.style.left = `${rect.right + window.scrollX - 20}px`;\n    }\n  }, [hoveredTable]);\n\n  const modifyTable = (action: string) => {\n    if (hoveredTable) {\n      editor.update(() => {\n        const tableNode = $getNodeByKey(hoveredTable.node.getKey());\n        if (!$isTableNode(tableNode)) return;\n\n        const firstRow = tableNode.getFirstChild();\n        const lastRow = tableNode.getLastChild();\n\n        switch (action) {\n          case \"delete-table\":\n            tableNode.remove();\n            break;\n          case \"add-row-start\":\n            if ($isTableRowNode(firstRow)) {\n              const firstCell = firstRow.getFirstChild();\n              if ($isTableCellNode(firstCell)) firstCell.selectStart();\n            }\n            $insertTableRowAtSelection(true);\n            break;\n          case \"add-row-end\":\n            if ($isTableRowNode(lastRow)) {\n              const lastCell = lastRow.getLastChild();\n              if ($isTableCellNode(lastCell)) lastCell.selectEnd();\n            }\n            $insertTableRowAtSelection(false);\n            break;\n          case \"delete-row-start\":\n            if ($isTableRowNode(firstRow)) {\n              const firstCell = firstRow.getFirstChild();\n              if ($isTableCellNode(firstCell)) firstCell.select();\n              $deleteTableRowAtSelection();\n            }\n            break;\n          case \"delete-row-end\":\n            if ($isTableRowNode(lastRow)) {\n              const lastCell = lastRow.getLastChild();\n              if ($isTableCellNode(lastCell)) lastCell.select();\n              $deleteTableRowAtSelection();\n            }\n            break;\n          case \"add-col-start\":\n            if ($isTableRowNode(firstRow)) {\n              const firstCell = firstRow.getFirstChild();\n              if ($isTableCellNode(firstCell)) firstCell.selectStart();\n            }\n            $insertTableColumnAtSelection(true);\n            break;\n          case \"add-col-end\":\n            if ($isTableRowNode(lastRow)) {\n              const lastCell = lastRow.getLastChild();\n              if ($isTableCellNode(lastCell)) lastCell.selectEnd();\n            }\n            $insertTableColumnAtSelection(false);\n            break;\n          case \"delete-col-start\":\n            if ($isTableRowNode(firstRow)) {\n              const firstCell = firstRow.getFirstChild();\n              if ($isTableCellNode(firstCell)) firstCell.select();\n              $deleteTableColumnAtSelection();\n            }\n            break;\n          case \"delete-col-end\":\n            if ($isTableRowNode(lastRow)) {\n              const lastCell = lastRow.getLastChild();\n              if ($isTableCellNode(lastCell)) lastCell.select();\n              $deleteTableColumnAtSelection();\n            }\n            break;\n        }\n      });\n    }\n  };\n\n  if (!hoveredTable) {\n    return null;\n  }\n\n  return createPortal(\n    <div ref={actionButtonRef} style={{ position: \"absolute\", zIndex: 100 }}>\n      <Menu>\n        <MenuTrigger\n          render={\n            <Button className=\"rounded-full\" size=\"icon\" variant=\"ghost\" />\n          }\n        >\n          <MoreHorizontal className=\"size-4\" />\n        </MenuTrigger>\n        <MenuPopup>\n          <MenuItem onClick={() => modifyTable(\"delete-table\")}>\n            Delete Table\n          </MenuItem>\n          <MenuSeparator />\n          <MenuItem onClick={() => modifyTable(\"add-row-start\")}>\n            Add Row Above\n          </MenuItem>\n          <MenuItem onClick={() => modifyTable(\"add-row-end\")}>\n            Add Row Below\n          </MenuItem>\n          <MenuItem onClick={() => modifyTable(\"delete-row-start\")}>\n            Delete First Row\n          </MenuItem>\n          <MenuItem onClick={() => modifyTable(\"delete-row-end\")}>\n            Delete Last Row\n          </MenuItem>\n          <MenuSeparator />\n          <MenuItem onClick={() => modifyTable(\"add-col-start\")}>\n            Add Column Before\n          </MenuItem>\n          <MenuItem onClick={() => modifyTable(\"add-col-end\")}>\n            Add Column After\n          </MenuItem>\n          <MenuItem onClick={() => modifyTable(\"delete-col-start\")}>\n            Delete First Column\n          </MenuItem>\n          <MenuItem onClick={() => modifyTable(\"delete-col-end\")}>\n            Delete Last Column\n          </MenuItem>\n        </MenuPopup>\n      </Menu>\n    </div>,\n    document.body\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/table-hover-actions/index.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/index.tsx",
      "content": "import { $isCodeNode } from \"@lexical/code\";\nimport { $isLinkNode, TOGGLE_LINK_COMMAND } from \"@lexical/link\";\nimport { $isListNode, ListNode } from \"@lexical/list\";\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { $isHeadingNode, $isQuoteNode } from \"@lexical/rich-text\";\nimport { $patchStyleText } from \"@lexical/selection\";\nimport { $isTableCellNode, INSERT_TABLE_COMMAND } from \"@lexical/table\";\nimport {\n  $findMatchingParent,\n  $getNearestNodeOfType,\n  mergeRegister,\n} from \"@lexical/utils\";\nimport {\n  $getSelection,\n  $isRangeSelection,\n  CAN_REDO_COMMAND,\n  CAN_UNDO_COMMAND,\n  COMMAND_PRIORITY_CRITICAL,\n  type ElementNode,\n  SELECTION_CHANGE_COMMAND,\n  type TextNode,\n} from \"lexical\";\nimport { Highlighter, LinkIcon, Mic, MicOff } from \"lucide-react\";\nimport { useCallback, useEffect, useReducer, useState } from \"react\";\nimport {\n  Menu,\n  MenuItem,\n  MenuPopup,\n  MenuSeparator,\n  MenuTrigger,\n} from \"@/registry/new-york/ui/menu\";\nimport { ImageDialog, LinkPopover, TableDialog } from \"../../components\";\nimport Separator from \"../../components/toolbar-separator\";\nimport { HIGHLIGHT_COLORS } from \"../../lib/colors\";\nimport { $createImageNode } from \"../../lib/nodes/image-node\";\nimport { AlignButtons } from \"./extensions/align-buttons\";\nimport { BlockFormatDropDown } from \"./extensions/block-format-dropdown\";\nimport { BlockTypeButtons } from \"./extensions/block-type-buttons\";\nimport { ColorPicker } from \"./extensions/color-picker\";\nimport { FileActions } from \"./extensions/file-actions\";\nimport { HistoryButtons } from \"./extensions/history-buttons\";\nimport { InsertDropDown } from \"./extensions/insert-actions\";\nimport { ListButtons } from \"./extensions/list-buttons\";\nimport { TableButtons } from \"./extensions/table-buttons\";\nimport { TextCaseMenu } from \"./extensions/text-case-menu\";\nimport { TextFormatButtons } from \"./extensions/text-format-buttons\";\nimport { ToolbarButton } from \"./extensions/toolbar-button\";\nimport { useSpeechToTextState } from \"../../plugins/speech-to-text\";\n\nconst initialState = {\n  isBold: false,\n  isItalic: false,\n  isUnderline: false,\n  isStrikethrough: false,\n  isCode: false,\n  isLink: false,\n  isHighlight: false,\n  isSubscript: false,\n  isSuperscript: false,\n  isCapitalized: false,\n  isUppercase: false,\n  isLowercase: false,\n  isTable: false,\n  isBulletedList: false,\n  isNumberedList: false,\n  isCheckList: false,\n  isQuote: false,\n  isCodeBlock: false,\n  blockType: \"paragraph\",\n  canUndo: false,\n  canRedo: false,\n};\n\nexport type ToolbarState = typeof initialState;\ntype Action =\n  | { type: \"UPDATE\"; payload: Partial<ToolbarState> }\n  | { type: \"SET_CAN_UNDO\"; payload: boolean }\n  | { type: \"SET_CAN_REDO\"; payload: boolean };\n\nconst toolbarReducer = (state: ToolbarState, action: Action): ToolbarState => {\n  switch (action.type) {\n    case \"UPDATE\":\n      return { ...state, ...action.payload };\n    case \"SET_CAN_UNDO\":\n      return { ...state, canUndo: action.payload };\n    case \"SET_CAN_REDO\":\n      return { ...state, canRedo: action.payload };\n    default:\n      return state;\n  }\n};\n\nexport function Toolbar({\n  enableSpeechToText = false,\n}: {\n  enableSpeechToText?: boolean;\n}) {\n  const [editor] = useLexicalComposerContext();\n  const [toolbarState, dispatch] = useReducer(toolbarReducer, initialState);\n  const [showLinkDialog, setShowLinkDialog] = useState(false);\n  const [showTableDialog, setShowTableDialog] = useState(false);\n  const [showImageDialog, setShowImageDialog] = useState(false);\n  const { isListening: isSpeechToTextActive } = useSpeechToTextState();\n\n  const updateToolbar = useCallback(() => {\n    editor.read(() => {\n      const selection = $getSelection();\n      const newToolbarState = {\n        isBulletedList: false,\n        isNumberedList: false,\n        isCheckList: false,\n        isQuote: false,\n        isCodeBlock: false,\n        isStrikethrough: false,\n        isBold: false,\n        isItalic: false,\n        isUnderline: false,\n        isCode: false,\n        isLink: false,\n        isHighlight: false,\n        isSubscript: false,\n        isSuperscript: false,\n        isCapitalized: false,\n        isUppercase: false,\n        isLowercase: false,\n        isTable: false,\n        blockType: \"paragraph\",\n      };\n\n      if ($isRangeSelection(selection)) {\n        const anchorNode = selection.anchor.getNode();\n        const element =\n          anchorNode.getKey() === \"root\"\n            ? anchorNode\n            : anchorNode.getTopLevelElementOrThrow();\n\n        let blockType = \"paragraph\";\n        if ($isListNode(element)) {\n          const parentList = $getNearestNodeOfType(anchorNode, ListNode);\n          blockType = parentList\n            ? parentList.getListType()\n            : element.getListType();\n        } else {\n          if ($isHeadingNode(element)) {\n            blockType = element.getTag();\n          } else if ($isQuoteNode(element)) {\n            blockType = \"quote\";\n          } else if ($isCodeNode(element)) {\n            blockType = \"code\";\n          }\n        }\n        newToolbarState.blockType = blockType;\n\n        const cell = $findMatchingParent(anchorNode, (node) =>\n          $isTableCellNode(node)\n        );\n        newToolbarState.isTable = cell !== null;\n\n        let isLink = false;\n        let node: ElementNode | TextNode | null = anchorNode;\n        while (node) {\n          if ($isLinkNode(node)) {\n            isLink = true;\n            break;\n          }\n          const parent: ElementNode | null = node.getParent();\n          if (parent === node) break;\n          node = parent;\n        }\n        newToolbarState.isLink = isLink;\n\n        newToolbarState.isBulletedList = blockType === \"bullet\";\n        newToolbarState.isNumberedList = blockType === \"number\";\n        newToolbarState.isCheckList = blockType === \"check\";\n        newToolbarState.isQuote = blockType === \"quote\";\n        newToolbarState.isCodeBlock = blockType === \"code\";\n\n        newToolbarState.isBold = selection.hasFormat(\"bold\");\n        newToolbarState.isItalic = selection.hasFormat(\"italic\");\n        newToolbarState.isUnderline = selection.hasFormat(\"underline\");\n        newToolbarState.isStrikethrough = selection.hasFormat(\"strikethrough\");\n        newToolbarState.isCode = selection.hasFormat(\"code\");\n        newToolbarState.isHighlight = selection.hasFormat(\"highlight\");\n        newToolbarState.isSubscript = selection.hasFormat(\"subscript\");\n        newToolbarState.isSuperscript = selection.hasFormat(\"superscript\");\n        newToolbarState.isCapitalized = selection.hasFormat(\"capitalize\");\n        newToolbarState.isUppercase = selection.hasFormat(\"uppercase\");\n        newToolbarState.isLowercase = selection.hasFormat(\"lowercase\");\n      }\n\n      dispatch({ type: \"UPDATE\", payload: newToolbarState });\n    });\n  }, [editor]);\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerUpdateListener(updateToolbar),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          updateToolbar();\n          return false;\n        },\n        COMMAND_PRIORITY_CRITICAL\n      ),\n      editor.registerCommand(\n        CAN_UNDO_COMMAND,\n        (payload: boolean) => {\n          dispatch({ type: \"SET_CAN_UNDO\", payload });\n          return false;\n        },\n        COMMAND_PRIORITY_CRITICAL\n      ),\n      editor.registerCommand(\n        CAN_REDO_COMMAND,\n        (payload: boolean) => {\n          dispatch({ type: \"SET_CAN_REDO\", payload });\n          return false;\n        },\n        COMMAND_PRIORITY_CRITICAL\n      )\n    );\n  }, [editor, updateToolbar]);\n\n  const insertLink = () => {\n    if (!toolbarState.isLink) {\n      setShowLinkDialog(true);\n    } else {\n      editor.dispatchCommand(TOGGLE_LINK_COMMAND, null);\n    }\n  };\n\n  const handleLinkSubmit = (url: string) => {\n    if (url) {\n      editor.dispatchCommand(TOGGLE_LINK_COMMAND, url);\n    }\n  };\n\n  const handleTableSubmit = (rows: number, columns: number) => {\n    const validRows = Math.max(1, Math.min(rows, 20));\n    const validColumns = Math.max(1, Math.min(columns, 20));\n    editor.dispatchCommand(INSERT_TABLE_COMMAND, {\n      columns: validColumns.toString(),\n      rows: validRows.toString(),\n    });\n  };\n\n  const handleImageSubmit = (src: string, alt: string) => {\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const imageNode = $createImageNode(src, alt);\n        selection.insertNodes([imageNode]);\n      }\n    });\n  };\n\n  return (\n    <div className=\"flex relative items-center gap-1 p-3 border-b flex-wrap\">\n      <HistoryButtons\n        canRedo={toolbarState.canRedo}\n        canUndo={toolbarState.canUndo}\n      />\n\n      <Separator />\n      <BlockFormatDropDown blockType={toolbarState.blockType} />\n\n      <Separator />\n\n      <ListButtons toolbarState={toolbarState} />\n      <BlockTypeButtons toolbarState={toolbarState} />\n\n      <Separator />\n\n      <TextFormatButtons toolbarState={toolbarState} />\n      <TextCaseMenu toolbarState={toolbarState} />\n      <Separator />\n      <ColorPicker editor={editor} />\n\n      <Menu>\n        <MenuTrigger\n          render={\n            <ToolbarButton\n              icon={Highlighter}\n              isActive={toolbarState.isHighlight}\n              title=\"Highlight\"\n            />\n          }\n        />\n        <MenuPopup className=\"animate-in slide-in-from-top-2 duration-200\">\n          {HIGHLIGHT_COLORS.map((color) => (\n            <MenuItem\n              className=\"hover:bg-accent/80 transition-colors\"\n              key={color.value}\n              onClick={() => {\n                editor.update(() => {\n                  const selection = $getSelection();\n                  if ($isRangeSelection(selection)) {\n                    $patchStyleText(selection, {\n                      \"background-color\": color.value,\n                    });\n                  }\n                });\n              }}\n            >\n              <div\n                className=\"size-4 rounded-sm mr-2 border shadow-sm\"\n                style={{ backgroundColor: color.value }}\n              />\n              {color.name}\n            </MenuItem>\n          ))}\n          <MenuSeparator />\n          <MenuItem\n            className=\"hover:bg-accent/80 transition-colors\"\n            onClick={() => {\n              editor.update(() => {\n                const selection = $getSelection();\n                if ($isRangeSelection(selection)) {\n                  $patchStyleText(selection, { \"background-color\": \"\" });\n                }\n              });\n            }}\n          >\n            Remove Highlight\n          </MenuItem>\n        </MenuPopup>\n      </Menu>\n      <Separator />\n      <LinkPopover\n        isOpen={showLinkDialog}\n        initialUrl=\"\"\n        onClose={() => setShowLinkDialog(false)}\n        onSubmit={handleLinkSubmit}\n        trigger={\n          <ToolbarButton\n            icon={LinkIcon}\n            isActive={toolbarState.isLink}\n            onClick={insertLink}\n            title=\"Insert Link\"\n          />\n        }\n      />\n\n      <Separator />\n\n      <InsertDropDown\n        setShowImageDialog={setShowImageDialog}\n        setShowTableDialog={setShowTableDialog}\n      />\n\n      {toolbarState.isTable && (\n        <>\n          <Separator />\n          <TableButtons />\n        </>\n      )}\n\n      <Separator />\n\n      <AlignButtons />\n\n      {enableSpeechToText && (\n        <>\n          <Separator />\n          <ToolbarButton\n            icon={isSpeechToTextActive ? MicOff : Mic}\n            isActive={isSpeechToTextActive}\n            onClick={() => {\n              const event = new CustomEvent(\"toggle-speech-to-text\");\n              window.dispatchEvent(event);\n            }}\n            title={\n              isSpeechToTextActive\n                ? \"Stop Speech to Text\"\n                : \"Start Speech to Text\"\n            }\n          />\n        </>\n      )}\n\n      <TableDialog\n        isOpen={showTableDialog}\n        onClose={() => setShowTableDialog(false)}\n        onSubmit={handleTableSubmit}\n      />\n\n      <ImageDialog\n        isOpen={showImageDialog}\n        onClose={() => setShowImageDialog(false)}\n        onSubmit={handleImageSubmit}\n      />\n\n      <Separator />\n\n      <FileActions />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/index.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/toolbar-items.ts",
      "content": "import {\n  INSERT_CHECK_LIST_COMMAND,\n  INSERT_ORDERED_LIST_COMMAND,\n  INSERT_UNORDERED_LIST_COMMAND,\n} from \"@lexical/list\";\nimport { FORMAT_TEXT_COMMAND } from \"lexical\";\nimport {\n  Bold,\n  CaseUpper,\n  Code,\n  CodeSquare,\n  Italic,\n  List,\n  ListChecks,\n  ListOrdered,\n  Quote,\n  Strikethrough,\n  Subscript,\n  Superscript,\n  Underline,\n} from \"lucide-react\";\n\nexport const TEXT_FORMAT_ITEMS = [\n  { name: \"bold\", icon: Bold, command: FORMAT_TEXT_COMMAND, payload: \"bold\" },\n  {\n    name: \"italic\",\n    icon: Italic,\n    command: FORMAT_TEXT_COMMAND,\n    payload: \"italic\",\n  },\n  {\n    name: \"underline\",\n    icon: Underline,\n    command: FORMAT_TEXT_COMMAND,\n    payload: \"underline\",\n  },\n  {\n    name: \"strikethrough\",\n    icon: Strikethrough,\n    command: FORMAT_TEXT_COMMAND,\n    payload: \"strikethrough\",\n  },\n  { name: \"code\", icon: Code, command: FORMAT_TEXT_COMMAND, payload: \"code\" },\n  {\n    name: \"subscript\",\n    icon: Subscript,\n    command: FORMAT_TEXT_COMMAND,\n    payload: \"subscript\",\n  },\n  {\n    name: \"superscript\",\n    icon: Superscript,\n    command: FORMAT_TEXT_COMMAND,\n    payload: \"superscript\",\n  },\n];\n\nexport const BLOCK_FORMAT_ITEMS = [\n  { name: \"bullet\", icon: List, command: INSERT_UNORDERED_LIST_COMMAND },\n  { name: \"number\", icon: ListOrdered, command: INSERT_ORDERED_LIST_COMMAND },\n  { name: \"check\", icon: ListChecks, command: INSERT_CHECK_LIST_COMMAND },\n  { name: \"quote\", icon: Quote, format: \"quote\" },\n  { name: \"code\", icon: CodeSquare, format: \"code\" },\n];\n",
      "type": "registry:lib",
      "target": "components/editor/plugins/toolbar/toolbar-items.ts"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/align-buttons.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\n\nimport { FORMAT_ELEMENT_COMMAND } from \"lexical\";\nimport { AlignCenter, AlignJustify, AlignLeft, AlignRight } from \"lucide-react\";\nimport {\n  Menu,\n  MenuItem,\n  MenuPopup,\n  MenuTrigger,\n} from \"@/registry/new-york/ui/menu\";\nimport { ToolbarButton } from \"./toolbar-button\";\n\nexport function AlignButtons() {\n  const [editor] = useLexicalComposerContext();\n\n  const formatElement = (format: \"left\" | \"center\" | \"right\" | \"justify\") => {\n    editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, format);\n  };\n\n  return (\n    <Menu>\n      <MenuTrigger\n        render={<ToolbarButton icon={AlignLeft} title=\"Text Alignment\" />}\n      />\n\n      <MenuPopup\n        align=\"start\"\n        className=\"animate-in slide-in-from-top-2 duration-200\"\n      >\n        <MenuItem\n          className=\"hover:bg-accent/80 transition-colors\"\n          onClick={() => formatElement(\"left\")}\n        >\n          <AlignLeft className=\"mr-2 size-4\" />\n          Left\n        </MenuItem>\n        <MenuItem\n          className=\"hover:bg-accent/80 transition-colors\"\n          onClick={() => formatElement(\"center\")}\n        >\n          <AlignCenter className=\"mr-2 size-4\" />\n          Center\n        </MenuItem>\n        <MenuItem\n          className=\"hover:bg-accent/80 transition-colors\"\n          onClick={() => formatElement(\"right\")}\n        >\n          <AlignRight className=\"mr-2 size-4\" />\n          Right\n        </MenuItem>\n        <MenuItem\n          className=\"hover:bg-accent/80 transition-colors\"\n          onClick={() => formatElement(\"justify\")}\n        >\n          <AlignJustify className=\"mr-2 size-4\" />\n          Justify\n        </MenuItem>\n      </MenuPopup>\n    </Menu>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/align-buttons.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/block-format-dropdown.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { $createHeadingNode } from \"@lexical/rich-text\";\nimport { $setBlocksType } from \"@lexical/selection\";\nimport {\n  $createParagraphNode,\n  $getSelection,\n  $isRangeSelection,\n} from \"lexical\";\nimport {\n  Check,\n  Heading,\n  Heading1,\n  Heading2,\n  Heading3,\n  Heading4,\n} from \"lucide-react\";\nimport {\n  Menu,\n  MenuItem,\n  MenuPopup,\n  MenuTrigger,\n} from \"@/registry/new-york/ui/menu\";\nimport { ToolbarButton } from \"./toolbar-button\";\n\nexport function BlockFormatDropDown({ blockType }: { blockType: string }) {\n  const [editor] = useLexicalComposerContext();\n\n  const formatHeading = (headingSize: \"h1\" | \"h2\" | \"h3\" | \"h4\") => {\n    if (blockType !== headingSize) {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $setBlocksType(selection, () => $createHeadingNode(headingSize));\n        }\n      });\n    }\n  };\n\n  const formatParagraph = () => {\n    if (blockType !== \"paragraph\") {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $setBlocksType(selection, () => $createParagraphNode());\n        }\n      });\n    }\n  };\n\n  return (\n    <Menu>\n      <MenuTrigger\n        className=\"lowercase\"\n        render={\n          <ToolbarButton\n            variant={\n              [\"h1\", \"h2\", \"h3\"].includes(blockType) ? \"secondary\" : \"ghost\"\n            }\n          />\n        }\n      >\n        {blockType === \"paragraph\" ? (\n          <Heading className=\"size-4\" />\n        ) : blockType === \"h1\" ? (\n          <Heading1 className=\"size-4\" />\n        ) : blockType === \"h2\" ? (\n          <Heading2 className=\"size-4\" />\n        ) : blockType === \"h3\" ? (\n          <Heading3 className=\"size-4\" />\n        ) : blockType === \"h4\" ? (\n          <Heading4 className=\"size-4\" />\n        ) : (\n          <Heading className=\"size-4\" />\n        )}\n      </MenuTrigger>\n      <MenuPopup align=\"start\">\n        {[\n          {\n            key: \"heading 1\",\n            icon: Heading1,\n            format: \"h1\",\n            state: blockType === \"h1\",\n            onClick: () => formatHeading(\"h1\"),\n          },\n          {\n            key: \"heading 2\",\n            icon: Heading2,\n            format: \"h2\",\n            state: blockType === \"h2\",\n            onClick: () => formatHeading(\"h2\"),\n          },\n          {\n            key: \"heading 3\",\n            icon: Heading3,\n            format: \"h3\",\n            state: blockType === \"h3\",\n            onClick: () => formatHeading(\"h3\"),\n          },\n          {\n            key: \"heading 4\",\n            icon: Heading4,\n            format: \"h4\",\n            state: blockType === \"h4\",\n            onClick: () => formatHeading(\"h4\"),\n          },\n          {\n            key: \"paragraph\",\n            icon: Heading,\n            format: \"p\",\n            state: blockType === \"paragraph\",\n            onClick: formatParagraph,\n          },\n        ].map(({ key, icon: Icon, state, onClick }) => (\n          <MenuItem\n            className={\"flex items-center justify-between gap-5\"}\n            key={key}\n            onClick={onClick}\n          >\n            <div className=\"flex items-center\">\n              <Icon className=\"size-4\" />{\" \"}\n              <span className=\"ml-2 capitalize text-sm text-muted-foreground\">\n                {key}\n              </span>\n            </div>\n            {state ? <Check className=\"ml-auto size-4\" /> : null}\n          </MenuItem>\n        ))}\n      </MenuPopup>\n    </Menu>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/block-format-dropdown.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/block-type-buttons.tsx",
      "content": "import { $createCodeNode } from \"@lexical/code\";\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { $createQuoteNode } from \"@lexical/rich-text\";\nimport { $setBlocksType } from \"@lexical/selection\";\nimport {\n  $createParagraphNode,\n  $getSelection,\n  $isRangeSelection,\n} from \"lexical\";\nimport type { ToolbarState } from \"..\";\nimport { BLOCK_FORMAT_ITEMS } from \"../toolbar-items\";\nimport { ToolbarToggleButton } from \"./toolbar-button\";\n\nconst BLOCK_TYPE_ITEMS = BLOCK_FORMAT_ITEMS.filter((item) => item.format);\n\nexport function BlockTypeButtons({\n  toolbarState,\n}: {\n  toolbarState: ToolbarState;\n}) {\n  const [editor] = useLexicalComposerContext();\n\n  const onClickHandler = (format: string) => {\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        if (toolbarState.blockType === format) {\n          $setBlocksType(selection, () => $createParagraphNode());\n        } else {\n          if (format === \"quote\") {\n            $setBlocksType(selection, () => $createQuoteNode());\n          } else if (format === \"code\") {\n            $setBlocksType(selection, () => $createCodeNode());\n          }\n        }\n      }\n    });\n  };\n\n  return (\n    <>\n      {BLOCK_TYPE_ITEMS.map((item) => {\n        return (\n          <ToolbarToggleButton\n            icon={item.icon}\n            isActive={toolbarState.blockType === item.name}\n            key={item.name}\n            onClick={() => onClickHandler(item.format!)}\n            title={item.name}\n          />\n        );\n      })}\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/block-type-buttons.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/color-picker.tsx",
      "content": "import {\n  $getSelectionStyleValueForProperty,\n  $patchStyleText,\n} from \"@lexical/selection\";\nimport {\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_CRITICAL,\n  type LexicalEditor,\n  SELECTION_CHANGE_COMMAND,\n} from \"lexical\";\nimport { Palette } from \"lucide-react\";\nimport { useCallback, useEffect, useState } from \"react\";\n\nimport {\n  Menu,\n  MenuItem,\n  MenuPopup,\n  MenuTrigger,\n} from \"@/registry/new-york/ui/menu\";\nimport { FONT_COLORS } from \"../../../lib/colors\";\nimport { ToolbarButton } from \"./toolbar-button\";\n\nexport function ColorPicker({\n  editor,\n  disabled = false,\n}: {\n  editor: LexicalEditor;\n  disabled?: boolean;\n}) {\n  const [color, setColor] = useState(\"hsl(var(--foreground))\");\n\n  const applyColor = useCallback(\n    (newColor: string) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $patchStyleText(selection, { color: newColor });\n        }\n      });\n    },\n    [editor],\n  );\n\n  useEffect(() => {\n    return editor.registerCommand(\n      SELECTION_CHANGE_COMMAND,\n      () => {\n        editor.read(() => {\n          const selection = $getSelection();\n          if ($isRangeSelection(selection)) {\n            setColor(\n              $getSelectionStyleValueForProperty(\n                selection,\n                \"color\",\n                \"hsl(var(--foreground))\",\n              ),\n            );\n          }\n        });\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    );\n  }, [editor]);\n\n  return (\n    <Menu>\n      <MenuTrigger render={<ToolbarButton disabled={disabled} />}>\n        <Palette className=\"size-4\" style={{ color }} />\n      </MenuTrigger>\n      <MenuPopup className=\"animate-in grid grid-cols-3 gap-1 slide-in-from-top-2 duration-200\">\n        {FONT_COLORS.map((c) => (\n          <MenuItem\n            className=\"\"\n            key={c.name}\n            onClick={() => applyColor(c.value)}\n          >\n            <div\n              className=\"size-4 rounded-sm border border-input/20 shadow-sm\"\n              style={{ backgroundColor: c.value }}\n            />\n            {c.name}\n          </MenuItem>\n        ))}\n      </MenuPopup>\n    </Menu>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/color-picker.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/file-actions.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { FileDown, FileUp } from \"lucide-react\";\nimport { useRef } from \"react\";\nimport {\n  Menu,\n  MenuItem,\n  MenuPopup,\n  MenuTrigger,\n} from \"@/registry/new-york/ui/menu\";\nimport {\n  copyAsPlainText,\n  exportAsHTML,\n  exportAsMarkdown,\n  importMarkdown,\n} from \"../../../lib/utils\";\nimport { ToolbarButton } from \"./toolbar-button\";\n\nexport function FileActions() {\n  const [editor] = useLexicalComposerContext();\n  const importInputRef = useRef<HTMLInputElement>(null);\n\n  const handleImport = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file) {\n      importMarkdown(editor, file);\n    }\n  };\n\n  return (\n    <>\n      <Menu>\n        <MenuTrigger\n          render={\n            <ToolbarButton\n              className=\"hover:bg-accent/80 transition-colors\"\n              icon={FileDown}\n              title=\"Export\"\n              variant=\"ghost\"\n            />\n          }\n        />\n        <MenuPopup\n          align=\"start\"\n          className=\"animate-in slide-in-from-top-2 duration-200\"\n        >\n          <MenuItem\n            className=\"hover:bg-accent/80 transition-colors\"\n            onClick={() => exportAsHTML(editor)}\n          >\n            Save as HTML\n          </MenuItem>\n          <MenuItem\n            className=\"hover:bg-accent/80 transition-colors\"\n            onClick={() => exportAsMarkdown(editor)}\n          >\n            Save as Markdown\n          </MenuItem>\n          <MenuItem\n            className=\"hover:bg-accent/80 transition-colors\"\n            onClick={() => copyAsPlainText(editor)}\n          >\n            Copy as Plain Text\n          </MenuItem>\n        </MenuPopup>\n      </Menu>\n\n      <input\n        accept=\".md,.markdown\"\n        className=\"hidden\"\n        onChange={handleImport}\n        ref={importInputRef}\n        type=\"file\"\n      />\n      <ToolbarButton\n        icon={FileUp}\n        onClick={() => importInputRef.current?.click()}\n        title=\"Import\"\n      />\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/file-actions.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/history-buttons.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\n\nimport { REDO_COMMAND, UNDO_COMMAND } from \"lexical\";\nimport { Redo, Undo } from \"lucide-react\";\nimport { ToolbarButton } from \"./toolbar-button\";\n\nexport function HistoryButtons({\n  canUndo,\n  canRedo,\n}: {\n  canUndo: boolean;\n  canRedo: boolean;\n}) {\n  const [editor] = useLexicalComposerContext();\n\n  return (\n    <>\n      <div>\n        <ToolbarButton\n          disabled={!canUndo}\n          icon={Undo}\n          onClick={() => editor.dispatchCommand(UNDO_COMMAND, undefined)}\n          title=\"Undo\"\n        />\n      </div>\n      <div>\n        <ToolbarButton\n          disabled={!canRedo}\n          icon={Redo}\n          onClick={() => editor.dispatchCommand(REDO_COMMAND, undefined)}\n          title=\"Redo\"\n        />\n      </div>\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/history-buttons.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/insert-actions.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { INSERT_HORIZONTAL_RULE_COMMAND } from \"@lexical/react/LexicalHorizontalRuleNode\";\nimport { ImageIcon, Minus, Plus, Table } from \"lucide-react\";\nimport {\n  Menu,\n  MenuItem,\n  MenuPopup,\n  MenuTrigger,\n} from \"@/registry/new-york/ui/menu\";\nimport { ToolbarButton } from \"./toolbar-button\";\n\nexport function InsertDropDown({\n  setShowTableDialog,\n  setShowImageDialog,\n}: {\n  setShowTableDialog: (show: boolean) => void;\n  setShowImageDialog: (show: boolean) => void;\n}) {\n  const [editor] = useLexicalComposerContext();\n\n  return (\n    <Menu>\n      <MenuTrigger render={<ToolbarButton icon={Plus} title=\"Insert\" />} />\n      <MenuPopup\n        align=\"start\"\n        className=\"animate-in slide-in-from-top-2 duration-200\"\n      >\n        <MenuItem\n          className=\"hover:bg-accent/80 transition-colors\"\n          onClick={() =>\n            editor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND, undefined)\n          }\n        >\n          <Minus className=\"mr-2 size-4\" />\n          Divider\n        </MenuItem>\n        <MenuItem\n          className=\"hover:bg-accent/80 transition-colors\"\n          onClick={() => setShowTableDialog(true)}\n        >\n          <Table className=\"mr-2 size-4\" />\n          Table\n        </MenuItem>\n        <MenuItem\n          className=\"hover:bg-accent/80 transition-colors\"\n          onClick={() => setShowImageDialog(true)}\n        >\n          <ImageIcon className=\"mr-2 size-4\" />\n          Image\n        </MenuItem>\n      </MenuPopup>\n    </Menu>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/insert-actions.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/list-buttons.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport type { ToolbarState } from \"..\";\nimport { BLOCK_FORMAT_ITEMS } from \"../toolbar-items\";\nimport { ToolbarToggleButton } from \"./toolbar-button\";\n\nconst LIST_ITEMS = BLOCK_FORMAT_ITEMS.filter(\n  (item) => item.command && [\"bullet\", \"number\", \"check\"].includes(item.name),\n);\n\nexport function ListButtons({ toolbarState }: { toolbarState: ToolbarState }) {\n  const [editor] = useLexicalComposerContext();\n\n  return (\n    <>\n      {LIST_ITEMS.map((item) => {\n        return (\n          <ToolbarToggleButton\n            icon={item.icon}\n            isActive={toolbarState.blockType === item.name}\n            key={item.name}\n            onClick={() => editor.dispatchCommand(item.command!, undefined)}\n            title={item.name}\n          />\n        );\n      })}\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/list-buttons.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/table-buttons.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\n\nimport {\n  $insertTableColumnAtSelection,\n  $insertTableRowAtSelection,\n} from \"@lexical/table\";\nimport { Columns, Rows } from \"lucide-react\";\nimport { Button } from \"@/registry/new-york/ui/button\";\n\nexport function TableButtons() {\n  const [editor] = useLexicalComposerContext();\n\n  const insertRow = () => {\n    editor.update(() => {\n      $insertTableRowAtSelection(true);\n    });\n  };\n\n  const insertColumn = () => {\n    editor.update(() => {\n      $insertTableColumnAtSelection(true);\n    });\n  };\n\n  return (\n    <>\n      <div>\n        <Button\n          onClick={insertRow}\n          size=\"icon-sm\"\n          title=\"Insert Row Below\"\n          variant=\"ghost\"\n        >\n          <Rows className=\"size-4\" />\n        </Button>\n      </div>\n      <div>\n        <Button\n          onClick={insertColumn}\n          size=\"icon-sm\"\n          title=\"Insert Column Right\"\n          variant=\"ghost\"\n        >\n          <Columns className=\"size-4\" />\n        </Button>\n      </div>\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/table-buttons.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/text-format-buttons.tsx",
      "content": "import { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport type { LexicalCommand } from \"lexical\";\nimport type { ToolbarState } from \"..\";\nimport { TEXT_FORMAT_ITEMS } from \"../toolbar-items\";\nimport { ToolbarToggleButton } from \"./toolbar-button\";\n\nexport function TextFormatButtons({\n  toolbarState,\n}: {\n  toolbarState: ToolbarState;\n}) {\n  const [editor] = useLexicalComposerContext();\n\n  const handleClick = (command: LexicalCommand<string>, payload?: string) => {\n    if (!payload) return;\n    editor.dispatchCommand(command, payload);\n  };\n\n  return (\n    <>\n      {TEXT_FORMAT_ITEMS.map((item) => (\n        <ToolbarToggleButton\n          icon={item.icon}\n          isActive={\n            !!toolbarState[\n              `is${\n                item.name.charAt(0).toUpperCase() + item.name.slice(1)\n              }` as keyof ToolbarState\n            ]\n          }\n          key={item.name}\n          onClick={() => handleClick(item.command, item.payload)}\n          title={item.name}\n        />\n      ))}\n    </>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/text-format-buttons.tsx"
    },
    {
      "path": "registry/new-york/blocks/editor/plugins/toolbar/extensions/toolbar-button.tsx",
      "content": "import type { VariantProps } from \"class-variance-authority\";\nimport type { LucideIcon } from \"lucide-react\";\nimport * as React from \"react\";\nimport { cn } from \"@/registry/new-york/libs/utils\";\nimport { Button, type buttonVariants } from \"@/registry/new-york/ui/button\";\nimport { Toggle } from \"@/registry/new-york/ui/toggle\";\n\ninterface ToggleProps {\n  onClick: () => void;\n  isActive: boolean;\n  icon: LucideIcon;\n  title: string;\n}\n\nexport function ToolbarToggleButton({\n  onClick,\n  isActive,\n  icon: Icon,\n  title,\n}: ToggleProps) {\n  return (\n    <Toggle\n      onMouseDown={(e) => e.preventDefault()}\n      onPressedChange={onClick}\n      pressed={isActive}\n      size=\"sm\"\n      title={title}\n    >\n      <Icon className=\"size-4\" />\n    </Toggle>\n  );\n}\n\ntype ToolbarButtonProps = React.ComponentProps<typeof Button> &\n  Partial<VariantProps<typeof buttonVariants>> & {\n    isActive?: boolean;\n    icon?: LucideIcon;\n    children?: React.ReactNode;\n  };\n\nexport const ToolbarButton = React.forwardRef<\n  HTMLButtonElement,\n  ToolbarButtonProps\n>(\n  (\n    {\n      className,\n      isActive = false,\n      children,\n      icon: Icon,\n      variant,\n      size = \"icon-sm\",\n      ...props\n    },\n    ref\n  ) => {\n    return (\n      <Button\n        className={cn(\"h-7 w-7 px-[calc(--spacing(1.5)-1px)]\", className)}\n        ref={ref}\n        size={size}\n        variant={variant ?? (isActive ? \"secondary\" : \"ghost\")}\n        {...props}\n      >\n        {children}\n        {Icon && <Icon className=\"size-4\" />}\n      </Button>\n    );\n  }\n);\n\nToolbarButton.displayName = \"ToolbarButton\";\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/extensions/toolbar-button.tsx"
    }
  ],
  "cssVars": {
    "light": {
      "editor-background": "oklch(1 0 0)",
      "editor-foreground": "oklch(0.145 0 0)",
      "editor-card": "oklch(1 0 0)",
      "editor-card-foreground": "oklch(0.145 0 0)",
      "editor-popover": "oklch(1 0 0)",
      "editor-popover-foreground": "oklch(0.145 0 0)",
      "editor-primary": "oklch(0.205 0 0)",
      "editor-primary-foreground": "oklch(0.985 0 0)",
      "editor-muted": "oklch(0.97 0 0)",
      "editor-muted-foreground": "oklch(0.556 0 0)",
      "editor-accent": "oklch(0.97 0 0)",
      "editor-accent-foreground": "oklch(0.205 0 0)",
      "editor-border": "oklch(0.922 0 0)",
      "editor-input": "oklch(0.922 0 0)",
      "editor-ring": "oklch(0.708 0 0)",
      "editor-radius": "0.5rem"
    },
    "dark": {
      "editor-background": "oklch(0.145 0 0)",
      "editor-foreground": "oklch(0.985 0 0)",
      "editor-card": "oklch(0.205 0 0)",
      "editor-card-foreground": "oklch(0.985 0 0)",
      "editor-popover": "oklch(0.205 0 0)",
      "editor-popover-foreground": "oklch(0.985 0 0)",
      "editor-primary": "oklch(0.922 0 0)",
      "editor-primary-foreground": "oklch(0.205 0 0)",
      "editor-muted": "oklch(0.269 0 0)",
      "editor-muted-foreground": "oklch(0.708 0 0)",
      "editor-accent": "oklch(0.269 0 0)",
      "editor-accent-foreground": "oklch(0.985 0 0)",
      "editor-border": "oklch(1 0 0 / 10%)",
      "editor-input": "oklch(1 0 0 / 15%)",
      "editor-ring": "oklch(0.556 0 0)",
      "editor-radius": "0.5rem"
    }
  },
  "meta": {
    "category": "blocks",
    "subcategory": "editor",
    "featured": true,
    "version": "1.0.0"
  },
  "docs": "https://uruhuu.vercel.app/docs/components/editor"
}